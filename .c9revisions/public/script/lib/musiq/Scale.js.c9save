{"ts":1360902593037,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Representation of a musical scale\nvar Scale = function( type ){\n   this.type = type;\n   \n};\n\n/**\n * create a scale from a tonic note and a type\n */\nScale.fromTonicAndType = function( tonic, type ){\n    \n};\n\n/**\n * extend a scale over a number of octaves\n */\nScale.extend = function( startOctave, endOctave ){\n    this.startOctave = startOctave;\n    this.endOctave = endOctave;\n}"]],"start1":0,"start2":0,"length1":0,"length2":381}]],"length":381}
{"contributors":[],"silentsave":false,"ts":1360902602258,"patch":[[{"diffs":[[0,"ctave;\n}"],[1,"\n\nScale.prototype.type = function(){\n    return \"Scale\";\n}"]],"start1":373,"start2":373,"length1":8,"length2":66}]],"length":439,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361206416582,"patch":[[{"diffs":[[0,"){\n    \n};\n\n"],[1,"Scale.fromNotation = function( name, octave ){\n    \n    // check if it's a valid notation, at least the note part\n    \n    var matches = MUSIQ.isValidChord( name );\n    \n    //console.log( matches );\n    \n    // no chord found?\n    if( !matches ){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }\n    \n    var tonic = Note.fromNotation( matches[1] + (matches[2] || \"\") );\n    //console.log( tonic );\n    var notation = matches[3];\n    \n    \n    if( !notation || notation.length == 0){\n        // set the default maj notation\n        notation = 'M';\n    }\n    //console.log( notation );\n    \n    // this should be only one!\n    var matchedScales = _(MUSIQ.scales).filter(function(scale){\n        return _(scale.names).some(function(name){ return name == notation });\n    });\n    \n    //console.log(\"matched chords for \" + notation );\n    //console.log(matchedChords);\n    \n    // we should check that the specific notation does not match\n    // more than 1 chord. if so, the definition in MUSIQ.chords \n    // contains duplicates\n    if( matchedScales.length > 0 ){\n        //console.log( \"matched Chords > 0! \");\n        //console.log(matchedChords);\n    }\n    console.assert( matchedScales.length == 1);\n    \n    // get the transposed notes\n    \n    // first add any optional notes\n    var allNotes = matchedChords[0].optional ?\n                      _(matchedChords[0].notes).union(matchedChords[0].optional).sort(function(a, b) { return a - b; })\n                    : matchedChords[0].notes;\n    \n    var transNotes = _(allNotes).map(function(note){\n        return (new Note(note)).transpose(tonic.pos).toRelative().pos;\n    })\n    \n    //console.log(\"Transnotes:\");\n    //console.log( transNotes ); \n    \n    // find the name in the chord names array\n    var chord = new Chord( transNotes, matchedChords[0], tonic );\n    \n    return chord;\n};\n\n"],[0,"/**\n * exten"]],"start1":198,"start2":198,"length1":24,"length2":1897}]],"length":2312,"saved":false}
{"ts":1361206491052,"patch":[[{"diffs":[[0,"matched "],[-1,"chord"],[1,"Scale"],[0,"s for \" "]],"start1":1032,"start2":1032,"length1":21,"length2":21},{"diffs":[[0,"sole.log(matched"],[-1,"Chord"],[1,"Scale"],[0,"s);\n    \n    // "]],"start1":1076,"start2":1076,"length1":37,"length2":37},{"diffs":[[0,"n MUSIQ."],[-1,"chord"],[1,"Scale"],[0,"s \n    /"]],"start1":1220,"start2":1220,"length1":21,"length2":21},{"diffs":[[0,"matched "],[-1,"Chord"],[1,"Scale"],[0,"s > 0! \""]],"start1":1323,"start2":1323,"length1":21,"length2":21},{"diffs":[[0,"(matched"],[-1,"Chord"],[1,"Scale"],[0,"s);\n    "]],"start1":1368,"start2":1368,"length1":21,"length2":21},{"diffs":[[0,"es = matched"],[-1,"Chord"],[1,"Scale"],[0,"s[0].optiona"]],"start1":1531,"start2":1531,"length1":29,"length2":29},{"diffs":[[0,"   _(matched"],[-1,"Chord"],[1,"Scale"],[0,"s[0].notes)."]],"start1":1583,"start2":1583,"length1":29,"length2":29},{"diffs":[[0,"nion(matched"],[-1,"Chord"],[1,"Scale"],[0,"s[0].optiona"]],"start1":1613,"start2":1613,"length1":29,"length2":29},{"diffs":[[0,"   : matched"],[-1,"Chord"],[1,"Scale"],[0,"s[0].notes;\n"]],"start1":1701,"start2":1701,"length1":29,"length2":29},{"diffs":[[0,"var "],[-1,"chord"],[1,"scale"],[0," = new "],[-1,"Chord"],[1,"Scale"],[0,"( tr"]],"start1":1994,"start2":1994,"length1":25,"length2":25},{"diffs":[[0," matched"],[-1,"Chord"],[1,"Scale"],[0,"s[0], to"]],"start1":2028,"start2":2028,"length1":21,"length2":21},{"diffs":[[0," return "],[-1,"chord"],[1,"scale"],[0,";\n};\n\n/*"]],"start1":2064,"start2":2064,"length1":21,"length2":21}]],"length":2312,"saved":false}
{"ts":1361206525891,"patch":[[{"diffs":[[0,"/"],[-1,"/ Representation of a musical scale"],[1,"**\n * the MUSIQ.js scale class\n * \n * @param notes : a simple array of integers representing the midi notes\n * @param descriptor : an object describing the scale\n * @param tonic : the current tonic Note oject\n * @param relative : if the scale should be interpreted as  relative, \n *                   i.e. can be positioned anywhere\n *                   on the musical scale (Fretboard for guitar)\n */"],[0,"\nvar"]],"start1":0,"start2":0,"length1":40,"length2":406}]],"length":2678,"saved":false}
{"ts":1361206535351,"patch":[[{"diffs":[[0,"nction( "],[-1,"typ"],[1,"notes, descriptor, tonic, relativ"],[0,"e ){\n   "]],"start1":417,"start2":417,"length1":19,"length2":49}]],"length":2708,"saved":false}
{"ts":1361206550331,"patch":[[{"diffs":[[0,"= type;\n   \n"],[1,"   if( descriptor.hasOwnProperty( 'names') ){\n        // notes in relative position\n        this.relNotes = descriptor.notes;\n        this.names = descriptor.names;\n        this.longName = descriptor.longName;\n        \n        //this.name = this.names[0];\n    }\n    \n    \n    this.notes = notes;\n    \n    \n    // if the chord is abstract, it has no tonic.\n    if( tonic ) this.abstract = false;\n    else        this.abstract = true;\n    \n    // if the chord is relative, it can be positioned anywhere\n    // on the musical axis\n    this.relative = relative || false;\n    // override this if the tonic is relative\n    this.relative = tonic.relative;\n    \n    // this should be a Note object\n    this.tonic = tonic || new Note(0);\n   \n"],[0,"};\n\n/**\n * c"]],"start1":476,"start2":476,"length1":24,"length2":757}]],"length":3441,"saved":false}
{"ts":1361206651111,"patch":[[{"diffs":[[0,"};\n\n"],[-1,"Scale.fromNotation = function( name, octave ){\n    \n    // check if it's a valid notation, at least the note part\n    \n    var matches = MUSIQ.isValidChord( name );\n    \n    //console.log( matches );\n    \n    // no chord found?\n    if( !matches ){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }\n    \n    var tonic = Note.fromNotation( matches[1] + (matches[2] || \"\") );\n    //console.log( tonic );\n    var notation = matches[3];\n    \n    \n    if( !notation || notation.length == 0){\n        // set the default maj notation\n        notation = 'M';\n    }\n    //console.log( notation );\n    \n    // this should be only one!\n    var matchedScales = _(MUSIQ.scales).filter(function(scale){\n        return _(scale.names).some(function(name){ return name == notation });\n    });\n    \n    //console.log(\"matched Scales for \" + notation );\n    //console.log(matchedScales);\n    \n    // we should check that the specific notation does not match\n    // more than 1 chord. if so, the definition in MUSIQ.Scales \n    // contains duplicates\n    if( matchedScales.length > 0 ){\n        //console.log( \"matched Scales > 0! \");\n        //console.log(matchedScales);\n    }\n    console.assert( matchedScales.length == 1);\n    \n    // get the transposed notes\n    \n    // first add any optional notes\n    var allNotes = matchedScales[0].optional ?\n                      _(matchedScales[0].notes).union(matchedScales[0].optional).sort(function(a, b) { return a - b; })\n                    : matchedScales[0].notes;\n    \n    var transNotes = _(allNotes).map(function(note){\n        return (new Note(note)).transpose(tonic.pos).toRelative().pos;\n    })\n    \n    //console.log(\"Transnotes:\");\n    //console.log( transNotes ); \n    \n    // find the name in the chord names array\n    var scale = new Scale( transNotes, matchedScales[0], tonic );\n    \n    return scale;\n};\n\n"],[0,"/**\n"]],"start1":1335,"start2":1335,"length1":1881,"length2":8}]],"length":1568,"saved":false}
{"ts":1361206665232,"patch":[[{"diffs":[[0,"e = "],[-1,"function( notes, descriptor, tonic, relative ){\n   this.type = type;\n   \n   if( descriptor.hasOwnProperty( 'names') ){\n        // notes in relative position\n        this.relNotes = descriptor.notes;\n        this.names = descriptor.names;\n        this.longName = descriptor.longName;\n        \n        //this.name = this.names[0];\n    }\n    \n    \n    this.notes = notes;\n    \n    \n    // if the chord is abstract, it has no tonic.\n    if( tonic ) this.abstract = false;\n    else        this.abstract = true;\n    \n    // if the chord is relative, it can be positioned anywhere\n    // on the musical axis\n    this.relative = relative || false;\n    // override this if the tonic is relative\n    this.relative = tonic.relative;\n    \n    // this should be a Note object\n    this.tonic = tonic || new Note(0);\n   \n};"],[0,"\n\n/*"]],"start1":411,"start2":411,"length1":816,"length2":8}]],"length":760,"saved":false}
{"ts":1361206732761,"patch":[[{"diffs":[[0,"Scale = "],[1,"_(Chord).extend;"],[0,"\n\n/**\n *"]],"start1":407,"start2":407,"length1":16,"length2":32}]],"length":776,"saved":false}
{"ts":1361206735028,"patch":[[{"diffs":[[0,").extend"],[1,"()"],[0,";\n\n/**\n "]],"start1":422,"start2":422,"length1":16,"length2":18}]],"length":778,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361207532268,"patch":[[{"diffs":[[0,"ar)\n */\n"],[1,"//"],[0,"var Scal"]],"start1":395,"start2":395,"length1":16,"length2":18}]],"length":780,"saved":false}
{"ts":1361207543766,"patch":[[{"diffs":[[0," */\n"],[-1,"//"],[0,"var "]],"start1":399,"start2":399,"length1":10,"length2":8},{"diffs":[[0,"Scale = "],[1,"{}; //"],[0,"_(Chord)"]],"start1":407,"start2":407,"length1":16,"length2":22}]],"length":784,"saved":false}
{"ts":1361207774497,"patch":[[{"diffs":[[0,"return \""],[-1,"S"],[1,"s"],[0,"cale\";\n}"]],"start1":767,"start2":767,"length1":17,"length2":17}]],"length":784,"saved":false}
{"ts":1361207798472,"patch":[[{"diffs":[[0,"ave;\n}\n\n"],[1,"/*"],[0,"Scale.pr"]],"start1":720,"start2":720,"length1":16,"length2":18},{"diffs":[[0,"cale\";\n}"],[1,"*/"]],"start1":778,"start2":778,"length1":8,"length2":10}]],"length":788,"saved":false}
