{"ts":1360857362073,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * the MUSIQ.js chord class\n * \n * @param notes : a simple array of integers representing the midi notes\n * @param descriptor : an object describing the chord\n * @param tonic : the current tonic Note oject\n * @param relative : if the chord should be interpreted as  relative, \n *                   i.e. can be positioned anywhere\n *                   on the musical scale (Fretboard for guitar)\n */\n\nvar Chord = function( notes, descriptor, tonic, relative ) {\n    \n    if( descriptor.hasOwnProperty( 'names') ){\n        // notes in relative position\n        this.relNotes = descriptor.notes;\n        this.names = descriptor.names;\n        this.longName = descriptor.longName;\n    }\n    // the descriptor is an array, just save the values\n    // here and \n    this.notes = notes;\n    \n    \n    // if the chord is abstract, it has no tonic.\n    if( tonic ) this.abstract = false;\n    else        this.abstract = true;\n    \n    // if the chord is relative, it can be positioned anywhere\n    // on the musical axis\n    this.relative = relative || false;\n    // override this if the tonic is relative\n    this.relative = tonic.relative;\n    \n    // this should be a Note object\n    this.tonic = tonic || new Note(0);\n};\n\n/**\n * constructs a Chord object from a notation like Cmaj7\n * \n * TODO: implement this method properly so it supports all accidentals\n */\n\nChord.fromNotation = function( name, octave ){\n    \n    var tonic;\n    var notation;\n    // set the tonic\n    if( name.indexOf('#') == 1 || name.indexOf('b') == 1 ){\n        // we have a sharp\n        tonic = Note.fromNotation(name.substring(0,2));\n        notation = name.substring(2);\n    } else {\n        // nothing special\n        tonic = Note.fromNotation(name.substring(0,1));\n        notation = name.substring(1);\n    }\n    \n    if( !notation || notation.length == 0){\n        // set the default maj notation\n        notation = 'M';\n    }\n    \n    // check if we have a valid notation and a valid tonic\n    \n    \n    \n    // get the chords that match the description.\n    \n    // this should be only one!\n    var matchedChords = _(MUSIQ.chords).filter(function(chord){\n        return _(chord.names).some(function(name){ return name == notation });\n    });\n    \n    console.log(\"matched chords for \" + notation );\n    console.log(matchedChords);\n    \n    // probably also check all alternative names for this chord\n    if( !tonic || !notation || !matchedChords || !(matchedChords.length > 0)){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }\n    \n    \n    // find the name in the chord names array\n    var chord = new Chord( matchedChords[0].notes, matchedChords[0], tonic );\n    \n    return chord;\n};\n\n/**\n * build a chord from individual notes\n * these can be note objects or just a list of integers\n * @param notes     : a simple array of integer notes\n * @param inversion : the number of the inversion, \n *                    0 = root position, 1 = first inversion, 2 = second inversion, ...\n * @returns an array of matching chords\n */\nChord.fromNotes = function( notes, inversion ){\n    \n    var ret = [];\n    \n    // make a nice array of Note objects from the notes parameter\n    var noteObjects = _.map( notes, function(note) {\n        return new Note(note);\n    });\n    \n    //console.log( \"fromNotes with inversion \" + inversion );\n    \n    if (_.isNumber(inversion) && inversion > -1) {\n        // specified an inversion, we first determine the tonic\n\n        // sort the notes from lowest to highest\n        var relNotes = notes.slice();\n\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //_.each(relNotes, function(item){console.log((new Note(item).notation()))});\n        \n        // determine the tonic - the lowest note\n        var tonic = relNotes[inversion];\n        var tonicNote = new Note(tonic);\n        //var relTonic = relNotes[0];\n\n        //var uniqueNotes = _.uniq(relNotes);\n\n        // make the notes relative to the tonic\n        relNotes = _.map(relNotes, function(note) {\n            return note - tonic;\n        });\n        \n        //console.log(relNotes);\n        \n        // wrap negative notes\n        relNotes = _.map( relNotes, function(note){\n            if( note < 0 ){\n                // move it enough octaves up\n                var n = note - (Math.floor( note / 12 ) * 12);\n                console.assert( n >= 0);\n                return n;\n            } else {\n                return note;\n            }\n        });\n        \n        //console.log(relNotes);\n        \n        // now find the chords for all the different possible inversions\n\n        //console.log(relNotes);\n\n\n        // get the notes within two octaves of the tonic\n        var relNotes = _.map(relNotes, function(note) {\n            if( note < 0 ) {\n                console.log(\"ERROR: negative note! \");\n            }\n            else if (note < 12) {\n                return note;\n            }\n            else {\n                // filter out special notes, like 9th, 11th and 13th\n                var relNote = note % 12;\n                if (MUSIQ.chordExtensionNotes.indexOf(relNote) > -1) {\n                    return relNote + 12;\n                }\n                else {\n                    return relNote;\n                }\n            }\n\n        });\n\n        //console.log(relNotes);\n        \n        \n        //console.log( relNotes );\n        // now remove duplicates\n        relNotes = _.uniq(relNotes);\n        \n        // sort the notes\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //console.log(inversion + \" : \" + tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n        \n        \n        //var foundTonics = [];\n        // find chords in the descriptor list that match\n        var matchedChordDescrs = _.filter(MUSIQ.chords, function(item) {\n            // remove the optional 5th chord\n            \n            if( item.optionalFifth ){\n                // match both to the item.notes array and the one without 7\n                // not array without the 5th (remove the 7 from the array)\n                var notesWOFifth = _.without(item.notes, 7);\n                \n                return _.isEqual(item.notes, relNotes ) || _.isEqual(notesWOFifth, relNotes);\n            } else {\n                return _.isEqual(item.notes, relNotes);\n            }\n        }, this);\n        \n        // filter duplicates\n        matchedChordDescrs = _.uniq(matchedChordDescrs);\n\n\n        // add the matched chords to the return array\n\n        var matchedChords = _.map( matchedChordDescrs, function(item){\n            return new Chord(noteObjects, item, new Note(tonic));\n        } );\n        \n        // only log this if we found a matched chord\n        if( matchedChords.length > 0){\n           // var tonicNote = new Note(tonic);\n            \n            //console.log(tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n            //console.log( \"found in inversion \" + inversion  + \"(\" + tonicNote.simpleNotation() + \") - [ \" + relNotes + \"]\");\n            //console.log(notes);\n            //console.log(relNotes);\n        }\n        \n        //console.log( matchedChords );\n        \n        return matchedChords;\n\n    }\n    // no inversion specified\n    else {\n        // simple list of chord tonics to check if we have looked for\n        // specific chords already\n        var chordTonics = [];\n        for (var i = 0; i < notes.length; i++) {\n            // add matched chords from all inversions of this chord\n            var curNote = new Note(notes[i]);\n            \n            if( chordTonics.indexOf(curNote.toRelative().pos) > -1){\n                continue;\n            }\n            \n            chordTonics.push(curNote.toRelative().pos);\n            \n            var matchedChords = Chord.fromNotes(notes, i);\n            \n            \n            ret = ret.concat(matchedChords);\n        }\n        \n        //console.log( chordTonics);\n        \n        // remove any duplicates\n        \n        \n        //console.log( ret );\n        \n        if( !(ret.length > 0) ){\n            //console.log(\"Chord not found!\");\n        }\n        return ret;\n    }\n    \n};\n\n/** instance methods **/\n\n/**\n * get the chord in proper notation\n */\nChord.prototype.notation = function() {\n    if( this.abstract ){\n        return this.names[0];\n    } else {\n        return this.tonic.simpleNotation() + this.names[0];\n    }\n};\n\n/**\n * get the name of the chord in long, readable notation\n */\nChord.prototype.longNotation = function() {\n    if( this.abstract ){\n        return this.longName;\n    } else {\n        return this.tonic.simpleNotation() + \" \" + this.longName;\n    }\n};\n\n/**\n * transpose a chard with a certain interval and return the new transposed\n * chord\n */\nChord.prototype.transpose = function(interval) {\n    // TODO; implement method\n    // transpose notes\n    this.notes = _(this.notes).map(function(note){\n        return note.transpose( interval );\n    });\n    // transpose tonic\n    this.tonic = this.tonic.transpose( interval );\n};\n\n/**\n * returns the absolute notes\n */\nChord.prototype.noteObjects = function(){\n    \n    // just return the simple list of notes\n    if( this._notes ) return this._notes;\n    \n    var allNotes =  _.map(  this.relNotes, \n                            function(note){ \n                                console.log(this.tonic.pos+note);\n                                return new Note(this.tonic.pos+note); \n                            }, this );\n    console.log(allNotes);\n    return allNotes;\n};\n\n/**\n * a simple toString function that gives us the notation of all the notes\n */\nChord.prototype.toString = function(){\n    var ret = \"[ \";\n    _.each(this.notes, function(item){ret += (new Note(item))});\n    return ret;\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":9729}]],"length":9729}
{"contributors":[],"silentsave":false,"ts":1360857381551,"patch":[[{"diffs":[[0,"    "],[-1,"// the descriptor is an array, just save the values\n    // here and"],[1,"\n   "],[0," \n  "]],"start1":687,"start2":687,"length1":75,"length2":12}]],"length":9666,"saved":false}
{"ts":1360857520148,"patch":[[{"diffs":[[0,"on];"],[-1,"\n        var tonicNote = new Note(tonic);\n        //var relTonic = relNotes[0];"],[0,"\n\n  "]],"start1":3717,"start2":3717,"length1":87,"length2":8},{"diffs":[[0,"te(tonic"],[1,", true"],[0,"));\n    "]],"start1":6471,"start2":6471,"length1":16,"length2":22}]],"length":9593,"saved":false}
{"ts":1360857544950,"patch":[[{"diffs":[[0,"    "],[-1,"// add the matched chords to the return array"],[0,"\n\n  "]],"start1":6295,"start2":6295,"length1":53,"length2":8},{"diffs":[[0,"(item){\n"],[1,"            // add the matched chords to the return array\n            // add the tonic as a relative note\n"],[0,"        "]],"start1":6364,"start2":6364,"length1":16,"length2":122}]],"length":9654,"saved":false}
{"ts":1360857945096,"patch":[[{"diffs":[[0,"ray\n"],[-1,"            // add the tonic as a relative note\n"],[0,"    "]],"start1":6426,"start2":6426,"length1":56,"length2":8},{"diffs":[[0,"onic"],[-1,", true"],[0,"));\n"]],"start1":6488,"start2":6488,"length1":14,"length2":8}]],"length":9600,"saved":false}
{"ts":1360859702598,"patch":[[{"diffs":[[0," octave ){\n    \n"],[1,"    // check if it's a valid notation, at least the note part\n    \n    \n    \n"],[0,"    var tonic;\n "]],"start1":1334,"start2":1334,"length1":32,"length2":109},{"diffs":[[0," var tonic;\n"],[-1,""],[0,"    var nota"]],"start1":1430,"start2":1430,"length1":24,"length2":24},{"diffs":[[0," tonic\n    \n"],[-1,"    \n    \n"],[0,"    // get t"]],"start1":1978,"start2":1978,"length1":34,"length2":24},{"diffs":[[0,"return;\n"],[1,""],[0,"    }\n  "]],"start1":2524,"start2":2524,"length1":16,"length2":16},{"diffs":[[0,"\n    }\n    \n"],[-1,"    \n"],[0,"    // find "]],"start1":2531,"start2":2531,"length1":29,"length2":24}]],"length":9662,"saved":false}
{"ts":1360861826815,"patch":[[{"diffs":[[0,"rt\n    \n    "],[1,"var regex = /^([A-G]|[a-g])(bbb|bb|b|#|##)? ?(maj7|M|maj|dim|major 7|major|m)?$/;\n    var matches = regex.exec( name );\n    console.log(matches);"],[0,"\n    \n    va"]],"start1":1409,"start2":1409,"length1":24,"length2":169}]],"length":9807,"saved":false}
{"ts":1360861963349,"patch":[[{"diffs":[[0,"ajor|m)?"],[1," ?(chord)?"],[0,"$/;\n    "]],"start1":1491,"start2":1491,"length1":16,"length2":26}]],"length":9817,"saved":false}
{"ts":1360862004769,"patch":[[{"diffs":[[0,"ec( name );\n"],[1,"    console.log(\"Matches:\");\n"],[0,"    console."]],"start1":1539,"start2":1539,"length1":24,"length2":53}]],"length":9846,"saved":false}
{"ts":1360862155788,"patch":[[{"diffs":[[0,"hord)?$/"],[1,"m"],[0,";\n    va"]],"start1":1503,"start2":1503,"length1":16,"length2":17}]],"length":9847,"saved":false}
{"ts":1360862424559,"patch":[[{"diffs":[[0,"regex = "],[-1,"/"],[1,"new RegExp(\""],[0,"^([A-G]|"]],"start1":1425,"start2":1425,"length1":17,"length2":28},{"diffs":[[0,"d)?$"],[-1,"/m"],[1,"\",\"m\")"],[0,";\n  "]],"start1":1517,"start2":1517,"length1":10,"length2":14}]],"length":9862,"saved":false}
{"ts":1360862942205,"patch":[[{"diffs":[[0,"e part\n    \n"],[1,"    var chordNames = _(MUSIQ.chords).reduce(function(c){\n        console.log(c);\n    })\n"],[0,"    var rege"]],"start1":1405,"start2":1405,"length1":24,"length2":112},{"diffs":[[0,"? ?("],[-1,"maj7|M|maj|dim|major 7|major|m"],[1,"\"+ chordNames + \""],[0,")? ?"]],"start1":1562,"start2":1562,"length1":38,"length2":25}]],"length":9937,"saved":false}
{"ts":1360862947863,"patch":[[{"diffs":[[0,";\n    })"],[1,";\n    "],[0,"\n    var"]],"start1":1496,"start2":1496,"length1":16,"length2":22}]],"length":9943,"saved":false}
{"ts":1360863181789,"patch":[[{"diffs":[[0,"unction("],[-1,"c"],[1,"memo, item"],[0,"){\n     "]],"start1":1462,"start2":1462,"length1":17,"length2":26},{"diffs":[[0,"    "],[-1,"console.log(c)"],[1,"memo += \"|\" + item.names.join(\"|\") + \"|\" + item.longName"],[0,";\n  "]],"start1":1487,"start2":1487,"length1":22,"length2":64}]],"length":9994,"saved":false}
{"ts":1360863199356,"patch":[[{"diffs":[[0,"e;\n    });\n    \n"],[1,"    console.log(chordNames);\n    \n"],[0,"    var regex = "]],"start1":1546,"start2":1546,"length1":32,"length2":66}]],"length":10028,"saved":false}
{"ts":1360863242785,"patch":[[{"diffs":[[0,"emo, item){\n"],[1,"        console.log(item);\n"],[0,"        memo"]],"start1":1471,"start2":1471,"length1":24,"length2":51}]],"length":10055,"saved":false}
{"ts":1360863576766,"patch":[[{"diffs":[[0,"    "],[1,"return "],[0,"memo +"],[-1,"="],[0," \"|\""]],"start1":1514,"start2":1514,"length1":15,"length2":21}]],"length":10061,"saved":false}
{"ts":1360863588482,"patch":[[{"diffs":[[0,"ole.log("],[-1,"it"],[1,"m"],[0,"em"],[1,"o"],[0,");\n     "]],"start1":1495,"start2":1495,"length1":20,"length2":20}]],"length":10061,"saved":false}
{"ts":1360863748141,"patch":[[{"diffs":[[0,"    "],[-1,"console.log(memo)"],[1,"var m = _(memo).isString() ? memo : memo.names.join(\"|\") + \"|\" + memo.longName"],[0,";\n  "]],"start1":1487,"start2":1487,"length1":25,"length2":86},{"diffs":[[0,"return m"],[-1,"emo"],[0," + \"|\" +"]],"start1":1579,"start2":1579,"length1":19,"length2":16}]],"length":10119,"saved":false}
{"ts":1360863769924,"patch":[[{"diffs":[[0,"emo, item){\n"],[1,"        console.log(m);\n"],[0,"        var "]],"start1":1471,"start2":1471,"length1":24,"length2":48},{"diffs":[[0,"o.longName;\n"],[1,"        console.log(m);\n"],[0,"        retu"]],"start1":1583,"start2":1583,"length1":24,"length2":48}]],"length":10167,"saved":false}
{"ts":1360863772089,"patch":[[{"diffs":[[0,"m){\n"],[-1,"        console.log(m);\n"],[0,"    "]],"start1":1479,"start2":1479,"length1":32,"length2":8}]],"length":10143,"saved":false}
{"ts":1360863938271,"patch":[[{"diffs":[[0,"ngName;\n        "],[1,"//"],[0,"console.log(m);\n"]],"start1":1563,"start2":1563,"length1":32,"length2":34}]],"length":10145,"saved":false}
{"ts":1360864299222,"patch":[[{"diffs":[[0,"optional"],[-1,"Fifth"],[0," ){\n    "]],"start1":6290,"start2":6290,"length1":21,"length2":16}]],"length":10140,"saved":false}
{"ts":1360864322984,"patch":[[{"diffs":[[0,"t match\n"],[1,"        \n        \n"],[0,"        "]],"start1":6130,"start2":6130,"length1":16,"length2":34},{"diffs":[[0,"rd\n            \n"],[1,"            // TODO: change this so it can optionally remove any note and\n            // still match\n"],[0,"            if( "]],"start1":6271,"start2":6271,"length1":32,"length2":133}]],"length":10259,"saved":false}
{"ts":1360864590976,"patch":[[{"diffs":[[0," still match"],[1,", not only 5th, but also 7th, 9th and 11th"],[0,"\n           "]],"start1":6375,"start2":6375,"length1":24,"length2":66}]],"length":10301,"saved":false}
{"ts":1360864662291,"patch":[[{"diffs":[[0,"var "],[-1,"chordNam"],[1,"match"],[0,"es = "],[-1,"_("],[0,"MUSIQ."],[-1,"chords).reduce(function(memo, item){\n        var m = _(memo).isString() ? memo : memo.names.join(\"|\") + \"|\" + memo.longName;\n        //console.log(m);\n        return m + \"|\" + item.names.join(\"|\") + \"|\" + item.longName;\n    });\n    \n    console.log(chordNames);\n    \n    var regex = new RegExp(\"^([A-G]|[a-g])(bbb|bb|b|#|##)? ?(\"+ chordNames + \")? ?(chord)?$\",\"m\");\n    var matches = regex.exec( name );\n    console.log(\"Matches:\");\n    console.log(matches"],[1,"isValidChord( name "],[0,");\n "]],"start1":1421,"start2":1421,"length1":485,"length2":43}]],"length":9859,"saved":false}
{"ts":1360864800722,"patch":[[{"diffs":[[0,"    "],[-1,"var tonic;\n    var notation;\n    // set the tonic\n    if( name.indexOf('#') == 1 || name.indexOf('b') == 1 ){\n        // we have a sharp\n        tonic = Note.fromNotation(name.substring(0,2));\n        notation = name.substring(2);\n    } else {"],[1,"// no chord found?\n    if( !matches ){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }"],[0,"\n    "],[-1,"    // nothing special\n        tonic = Note.fromNotation(name.substring(0,1))"],[1,"\n    var tonic"],[0,";\n    "],[-1,"   "],[1,"var"],[0," not"]],"start1":1468,"start2":1468,"length1":342,"length2":147},{"diffs":[[0,"tion"],[-1," = name.substring(1)"],[0,";\n    "],[-1,"}"],[0,"\n   "]],"start1":1616,"start2":1616,"length1":35,"length2":14},{"diffs":[[0,"   \n"],[-1,"    // check if we have a valid notation and a valid tonic\n    \n    // get the chords that match the description.\n    \n"],[0,"    "]],"start1":1747,"start2":1747,"length1":127,"length2":8},{"diffs":[[0,"    "],[-1,"\n    // probably also check all alternative names for this chord\n    if( !tonic || !notation || !matchedChords || !(matchedChords.length > 0)){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }"],[1,""],[0,"\n   "]],"start1":2023,"start2":2023,"length1":224,"length2":8}]],"length":9308,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360864933706,"patch":[[{"diffs":[[0,"Notes);\n"],[-1,"        \n        "],[0,"\n       "]],"start1":4717,"start2":4717,"length1":33,"length2":16},{"diffs":[[0,"\");\n"],[-1,"        \n        \n        //var foundTonics = [];"],[0,"\n   "]],"start1":5017,"start2":5017,"length1":57,"length2":8},{"diffs":[[0,"t match\n"],[-1,"        \n        \n"],[0,"        "]],"start1":5071,"start2":5071,"length1":34,"length2":16}]],"length":9224,"saved":false}
{"ts":1360867411838,"patch":[[{"diffs":[[0,"ame );\n    \n"],[1,"    console.log( matches );\n    \n"],[0,"    // no ch"]],"start1":1456,"start2":1456,"length1":24,"length2":57},{"diffs":[[0,"   var tonic"],[-1,";"],[1," = matches"],[0,"\n    var not"]],"start1":1623,"start2":1623,"length1":25,"length2":34}]],"length":9266,"saved":false}
{"ts":1360867472269,"patch":[[{"diffs":[[0,"tonic = "],[-1,"matches"],[1,"Note.fromNotation( matches[1] + matches[2] );"],[0,"\n    var"]],"start1":1630,"start2":1630,"length1":23,"length2":61},{"diffs":[[0,"notation"],[1," = matches[3]"],[0,";\n    \n "]],"start1":1692,"start2":1692,"length1":16,"length2":29}]],"length":9317,"saved":false}
{"ts":1360867879626,"patch":[[{"diffs":[[0,"lidChord"],[1,"Notation"],[0,"( name )"]],"start1":1445,"start2":1445,"length1":16,"length2":24}]],"length":9325,"saved":false}
{"ts":1360868030981,"patch":[[{"diffs":[[0,"tches[2] );\n"],[1,"    console.log( tonic );\n"],[0,"    var nota"]],"start1":1680,"start2":1680,"length1":24,"length2":50}]],"length":9351,"saved":false}
{"ts":1360868083115,"patch":[[{"diffs":[[0,"on = 'M';\n    }\n"],[1,"    console.log( notation );\n"],[0,"    \n    // this"]],"start1":1857,"start2":1857,"length1":32,"length2":61}]],"length":9380,"saved":false}
{"ts":1360868135333,"patch":[[{"diffs":[[0,"es[1] + "],[1,"("],[0,"matches["]],"start1":1670,"start2":1670,"length1":16,"length2":17},{"diffs":[[0,"tches[2]"],[1," || \"\")"],[0," );\n    "]],"start1":1681,"start2":1681,"length1":16,"length2":23}]],"length":9388,"saved":false}
{"ts":1360868223621,"patch":[[{"diffs":[[0,"ords);\n    \n"],[1,"    // we should check that the specific notation does not match\n    // more than 1 chord. if so, the definition in MUSIQ.chords \n    // contains duplicates\n    console.assert( matchedChords.length == 1);\n"],[0,"    \n    // "]],"start1":2180,"start2":2180,"length1":24,"length2":229}]],"length":9593,"saved":false}
{"ts":1360868237978,"patch":[[{"diffs":[[0,"notation );\n    "],[1,"//"],[0,"console.log(matc"]],"start1":2143,"start2":2143,"length1":32,"length2":34}]],"length":9595,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360868546990,"patch":[[{"diffs":[[0,"] || \"\") );\n    "],[1,"//"],[0,"console.log( ton"]],"start1":1688,"start2":1688,"length1":32,"length2":34}]],"length":9597,"saved":false}
{"ts":1360868732826,"patch":[[{"diffs":[[0,"rn ret;\n};\n\n"],[1,"\n/**\n * the plural class, simply to expose some functions in a more\n * logical way\n */\nvar Chords = {};\nChords.fromNotation = Chord.fromNotation;\n\n"]],"start1":9585,"start2":9585,"length1":12,"length2":159}]],"length":9744,"saved":false}
{"ts":1360868861000,"patch":[[{"diffs":[[0,"s = {};\n"],[1,"Chords.fromNotes = Chord.fromNotes;\n"],[0,"Chords.f"]],"start1":9693,"start2":9693,"length1":16,"length2":52}]],"length":9780,"saved":false}
{"ts":1360869491890,"patch":[[{"diffs":[[0,"lidChord"],[-1,"Notation"],[0,"( name )"]],"start1":1445,"start2":1445,"length1":24,"length2":16}]],"length":9772,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360880587230,"patch":[[{"diffs":[[0,"lNotes;\n};\n\n"],[1,"/**\n * check if the chord can be described by a simple name\n */\nChord.prototype.hasName = function(name){\n    return _(this.names).find(function(n){\n        return name = n;\n    });\n}\n\n"],[0,"/**\n * a sim"]],"start1":9351,"start2":9351,"length1":24,"length2":209}]],"length":9957,"saved":false}
{"ts":1360880594246,"patch":[[{"diffs":[[0,"n name ="],[1,"="],[0," n;\n    "]],"start1":9525,"start2":9525,"length1":16,"length2":17}]],"length":9958,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360888541169,"patch":[[{"diffs":[[0,"r.longName;\n"],[1,"        \n        this.name = this.names[0];\n"],[0,"    }\n    \n "]],"start1":669,"start2":669,"length1":24,"length2":68}]],"length":10002,"saved":false}
{"ts":1360889772725,"patch":[[{"diffs":[[0,"ame );\n    \n    "],[1,"//"],[0,"console.log( mat"]],"start1":1500,"start2":1500,"length1":32,"length2":34}]],"length":10004,"saved":false}
{"ts":1360889783218,"patch":[[{"diffs":[[0,";\n    }\n    "],[1,"//"],[0,"console.log("]],"start1":1913,"start2":1913,"length1":24,"length2":26},{"diffs":[[0,");\n    \n    "],[1,"//"],[0,"console.log("]],"start1":2137,"start2":2137,"length1":24,"length2":26}]],"length":10008,"saved":false}
{"ts":1360893472537,"patch":[[{"diffs":[[0,"== 1);\n    \n"],[1,"    // get the transposed notes\n    var transNotes = _(matchedChords[0].notes).map(function(note){\n        return (new Note(note)).transpose(tonic.pos).pos;\n    })\n    \n"],[0,"    // find "]],"start1":2436,"start2":2436,"length1":24,"length2":193}]],"length":10177,"saved":false}
{"ts":1360893498589,"patch":[[{"diffs":[[0,"ic.pos)."],[-1,"pos"],[1,"toRelative()"],[0,";\n    })"]],"start1":2592,"start2":2592,"length1":19,"length2":28}]],"length":10186,"saved":false}
{"ts":1360893519958,"patch":[[{"diffs":[[0,"    })\n    \n"],[1,"    console.log(\"Transnotes:\");\n    console.log( transNotes ); \n    \n"],[0,"    // find "]],"start1":2614,"start2":2614,"length1":24,"length2":93}]],"length":10255,"saved":false}
{"ts":1360893531082,"patch":[[{"diffs":[[0," Chord( "],[-1,"matchedChords[0].n"],[1,"transN"],[0,"otes, ma"]],"start1":2760,"start2":2760,"length1":34,"length2":22}]],"length":10243,"saved":false}
{"ts":1360893823709,"patch":[[{"diffs":[[0,"lative()"],[1,".pos"],[0,";\n    })"]],"start1":2604,"start2":2604,"length1":16,"length2":20}]],"length":10247,"saved":false}
{"ts":1360894317226,"patch":[[{"diffs":[[0,"       \n        "],[1,"//"],[0,"this.name = this"]],"start1":682,"start2":682,"length1":32,"length2":34}]],"length":10249,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360902550635,"patch":[[{"diffs":[[0,"et;\n};\n\n"],[1,"/**\n * the minimal notes needed to form this chord\n * @returns an array with the notes that are minimally necessary\n * to form this chord\n */\nChord.prototype.minNotes = function(){\n    \n    return _(this.notes).filter(function(note){\n        return !_(this.optional).contains(note);\n    });\n}\n\nChord.prototype.type = function(){\n    return \"Chord\";\n}\n\n"],[0,"\n/**\n * "]],"start1":10058,"start2":10058,"length1":16,"length2":368}]],"length":10601,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361037342547,"patch":[[{"diffs":[[0,"his.names[0]"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    } else"]],"start1":8438,"start2":8438,"length1":24,"length2":59},{"diffs":[[0," + this.names[0]"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    }\n};\n\n/**\n"]],"start1":8542,"start2":8542,"length1":32,"length2":67},{"diffs":[[0,"his.longName"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    } else"]],"start1":8754,"start2":8754,"length1":24,"length2":59},{"diffs":[[0,"his.longName"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    }\n};\n\n"]],"start1":8868,"start2":8868,"length1":24,"length2":59},{"diffs":[[0," absolute notes\n"],[1," * \n * save it in a local variable _notes for easy access\n"],[0," */\nChord.protot"]],"start1":9319,"start2":9319,"length1":32,"length2":90},{"diffs":[[0,"    "],[-1,"var allN"],[1,"this._n"],[0,"otes"]],"start1":9535,"start2":9535,"length1":16,"length2":15},{"diffs":[[0,"ole.log("],[-1,"allN"],[1,"\"NoteObjects\");\n    console.log(this._n"],[0,"otes);\n "]],"start1":9807,"start2":9807,"length1":20,"length2":55},{"diffs":[[0,"urn "],[-1,"allN"],[1,"this._n"],[0,"otes"]],"start1":9868,"start2":9868,"length1":12,"length2":15}]],"length":10836,"saved":false}
{"ts":1361037883574,"patch":[[{"diffs":[[0," duplicates\n"],[1,"    if( matchedChords.length > 0 ){\n        console.log( \"matched Chords > 0! \");\n        console.log(matchedChords);\n    }\n"],[0,"    console."]],"start1":2385,"start2":2385,"length1":24,"length2":148}]],"length":10960,"saved":false}
{"ts":1361038140357,"patch":[[{"diffs":[[0," = _"],[1,"(item.notes)"],[0,".wi"],[1,"d"],[0,"thout("],[-1,"item.notes, 7"],[1,"7);\n                console.log( notesWOFifth "],[0,");\n "]],"start1":6349,"start2":6349,"length1":30,"length2":76}]],"length":11006,"saved":false}
{"ts":1361038144985,"patch":[[{"diffs":[[0,"otes).wi"],[-1,"d"],[0,"thout(7)"]],"start1":6360,"start2":6360,"length1":17,"length2":16}]],"length":11005,"saved":false}
{"ts":1361038250404,"patch":[[{"diffs":[[0,"s + \" ]\");\n\n"],[1,"        console.log(\"Check descriptors\");\n        \n"],[0,"        // f"]],"start1":5790,"start2":5790,"length1":24,"length2":75}]],"length":11056,"saved":false}
{"ts":1361038323798,"patch":[[{"diffs":[[0,"WOFifth "],[1,"+ \" - \" + relNotes "],[0,");\n     "]],"start1":6463,"start2":6463,"length1":16,"length2":35}]],"length":11075,"saved":false}
{"ts":1361038515456,"patch":[[{"diffs":[[0,"scrs = _"],[-1,".filter"],[0,"(MUSIQ.c"]],"start1":5936,"start2":5936,"length1":23,"length2":16},{"diffs":[[0,"Q.chords"],[-1,", "],[1,").filter("],[0,"function"]],"start1":5949,"start2":5949,"length1":18,"length2":25}]],"length":11075,"saved":false}
{"ts":1361038528227,"patch":[[{"diffs":[[0,"b; });\n\n        "],[-1,"//"],[0,"console.log(inve"]],"start1":5696,"start2":5696,"length1":34,"length2":32}]],"length":11073,"saved":false}
{"ts":1361038577055,"patch":[[{"diffs":[[0,"unction("],[-1,"item"],[1,"chord"],[0,") {\n    "]],"start1":5965,"start2":5965,"length1":20,"length2":21},{"diffs":[[0,"fth = _("],[-1,"item"],[1,"chord"],[0,".notes)."]],"start1":6396,"start2":6396,"length1":20,"length2":21},{"diffs":[[0,"eturn _.isEqual("],[-1,"item"],[1,"chord"],[0,".notes, relNotes"]],"start1":6527,"start2":6527,"length1":36,"length2":37},{"diffs":[[0,"isEqual("],[-1,"item"],[1,"chord"],[0,".notes, "]],"start1":6651,"start2":6651,"length1":20,"length2":21}]],"length":11077,"saved":false}
{"ts":1361038735137,"patch":[[{"diffs":[[0," \" +"],[-1," tonicNote.simpleNotation() +"],[0," \" ["]],"start1":5739,"start2":5739,"length1":37,"length2":8}]],"length":11048,"saved":false}
{"ts":1361038755441,"patch":[[{"diffs":[[0,"    if( "],[-1,"item"],[1,"chord"],[0,".optiona"]],"start1":6162,"start2":6162,"length1":20,"length2":21}]],"length":11049,"saved":false}
{"ts":1361039297139,"patch":[[{"diffs":[[0,"fth = _("],[-1,"chord.n"],[1,"relN"],[0,"otes).wi"]],"start1":6368,"start2":6368,"length1":23,"length2":20},{"diffs":[[0,"without("],[-1,"7"],[1,"chord.optional"],[0,");\n     "]],"start1":6386,"start2":6386,"length1":17,"length2":30},{"diffs":[[0,"h + \" - \" + "],[-1,"relN"],[1,"chord.n"],[0,"otes );\n    "]],"start1":6451,"start2":6451,"length1":28,"length2":31}]],"length":11062,"saved":false}
{"ts":1361039360568,"patch":[[{"diffs":[[0,"    return _"],[-1,".isEqual"],[0,"(chord.notes"]],"start1":6507,"start2":6507,"length1":32,"length2":24},{"diffs":[[0,"rn _(chord.notes"],[-1,", "],[1,").isEqual("],[0,"relNotes ) || _."]],"start1":6515,"start2":6515,"length1":34,"length2":42},{"diffs":[[0,"s ) || _"],[1,"(chord.notes)"],[0,".isEqual"]],"start1":6548,"start2":6548,"length1":16,"length2":29},{"diffs":[[0,"sWOFifth"],[-1,", relNotes"],[0,");\n     "]],"start1":6582,"start2":6582,"length1":26,"length2":16}]],"length":11065,"saved":false}
{"ts":1361039398544,"patch":[[{"diffs":[[0,"return _"],[-1,".isEqual"],[0,"(chord.n"]],"start1":6630,"start2":6630,"length1":24,"length2":16},{"diffs":[[0,"rd.notes"],[-1,", "],[1,").isEqual("],[0,"relNotes"]],"start1":6642,"start2":6642,"length1":18,"length2":26}]],"length":11065,"saved":false}
{"ts":1361039427295,"patch":[[{"diffs":[[0," // "],[-1,"match both to the item.notes array and the one without 7\n                // not array without the 5th (remove the 7 from th"],[1,"remove all optional notes from the sourc"],[0,"e array"],[-1,")"],[0,"\n   "]],"start1":6203,"start2":6203,"length1":139,"length2":55},{"diffs":[[0,"ional);\n"],[1,"                \n"],[0,"        "]],"start1":6319,"start2":6319,"length1":16,"length2":33}]],"length":10998,"saved":false}
{"ts":1361039497648,"patch":[[{"diffs":[[0,"es)."],[-1,"without"],[1,"difference"],[0,"(cho"]],"start1":6298,"start2":6298,"length1":15,"length2":18}]],"length":11001,"saved":false}
{"ts":1361039548973,"patch":[[{"diffs":[[0,"    "],[-1,"// remove the optional 5th chord\n            \n            // TODO: change this so it can optionally remove any note and\n            // still match, not only 5th, but also 7th, 9th and 11th"],[1,"\n            "],[0,"\n   "]],"start1":5961,"start2":5961,"length1":196,"length2":21},{"diffs":[[0,"ar notes"],[-1,"WOFifth"],[1,"Req"],[0," = _(rel"]],"start1":6097,"start2":6097,"length1":23,"length2":19},{"diffs":[[0,"g( notes"],[-1,"WOFifth"],[1,"Req"],[0," + \" - \""]],"start1":6194,"start2":6194,"length1":23,"length2":19},{"diffs":[[0,"otes"],[-1,"WOFifth"],[1,"Req"],[0,");\n "]],"start1":6332,"start2":6332,"length1":15,"length2":11}]],"length":10814,"saved":false}
{"ts":1361039568258,"patch":[[{"diffs":[[0,"ource array\n"],[1,"                \n                // so we're only left with the absolute required notes to form this chord\n"],[0,"            "]],"start1":6068,"start2":6068,"length1":24,"length2":131}]],"length":10921,"saved":false}
{"ts":1361040099427,"patch":[[{"diffs":[[0,"    "],[-1,"var transNotes = _(matchedChords[0].n"],[1,"\n    // first add any optional notes\n    var allNotes = matchedChords[0].optional ?\n                      _(matchedChords[0].notes).union(matchedChords[0].optional).sort(function(a, b) { return a - b; })\n                    : matchedChords[0].notes;\n    \n    var transNotes = _(allN"],[0,"otes"]],"start1":2606,"start2":2606,"length1":45,"length2":290}]],"length":11166,"saved":false}
{"ts":1361040403126,"patch":[[{"diffs":[[0,"ional);\n"],[1,"                var chordNotesReq = _(chord.notes).difference(chord.optional);\n"],[0,"        "]],"start1":6495,"start2":6495,"length1":16,"length2":95},{"diffs":[[0,"               \n"],[-1,""],[0,"                "]],"start1":6583,"start2":6583,"length1":32,"length2":32},{"diffs":[[0,"  return _(chord"],[-1,".n"],[1,"N"],[0,"otes"],[1,"Req"],[0,").isEqual(relNot"]],"start1":6693,"start2":6693,"length1":38,"length2":40},{"diffs":[[0,"tes ) || _(chord"],[-1,".n"],[1,"N"],[0,"otes"],[1,"Req"],[0,").isEqual(notesR"]],"start1":6732,"start2":6732,"length1":38,"length2":40}]],"length":11249,"saved":false}
{"ts":1361040606283,"patch":[[{"diffs":[[0,"                "],[1,"//"],[0,"console.log( not"]],"start1":6599,"start2":6599,"length1":32,"length2":34}]],"length":11251,"saved":false}
{"ts":1361042502388,"patch":[[{"diffs":[[0,"b; });\n\n        "],[1,"//"],[0,"console.log(inve"]],"start1":5941,"start2":5941,"length1":32,"length2":34},{"diffs":[[0,"\" ]\");\n\n        "],[1,"//"],[0,"console.log(\"Che"]],"start1":6010,"start2":6010,"length1":32,"length2":34}]],"length":11255,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069072948,"patch":[[{"diffs":[[0," });\n}\n\n"],[1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(note){\n    if( note.relative ){\n        return _(relNotes)\n    } else {\n        \n    }\n    \n}\n\n"],[0,"/**\n * a"]],"start1":10486,"start2":10486,"length1":16,"length2":192}]],"length":11431,"saved":false}
{"ts":1361069099728,"patch":[[{"diffs":[[0,"eturn _("],[1,"this."],[0,"relNotes"]],"start1":10616,"start2":10616,"length1":16,"length2":21},{"diffs":[[0,"elNotes)"],[1,".contains(note.pos);"],[0,"\n    } e"]],"start1":10630,"start2":10630,"length1":16,"length2":36},{"diffs":[[0,"e {\n        "],[1,"return _(this.notes).contains(note.pos);"],[0,"\n    }\n    \n"]],"start1":10668,"start2":10668,"length1":24,"length2":64}]],"length":11496,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069496948,"patch":[[{"diffs":[[0,"ains = function("],[-1,""],[0,""],[1,"chord, "],[0,"note){\n    if( n"]],"start1":10559,"start2":10559,"length1":32,"length2":39},{"diffs":[[0,"eturn _("],[-1,"this"],[1,"chord"],[0,".relNote"]],"start1":10623,"start2":10623,"length1":20,"length2":21},{"diffs":[[0,"       return _("],[-1,"this"],[1,"chord"],[0,".notes).contains"]],"start1":10681,"start2":10681,"length1":36,"length2":37},{"diffs":[[0,";\n    }\n"],[-1,"    \n"],[0,"}"],[1,";"],[0,"\n\n/**\n *"]],"start1":10728,"start2":10728,"length1":22,"length2":18},{"diffs":[[0,"rd\";\n}\n\n"],[1,"/**\n * check if a Chord contains a note\n */\nChord.prototype.contains = function( note ){\n    \n}\n\n"],[0,"\n/**\n * "]],"start1":11310,"start2":11310,"length1":16,"length2":113}]],"length":11598,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069524775,"patch":[[{"diffs":[[0," ){\n    "],[1,"return Chord.contains( this. note );"],[0,"\n}\n\n\n/**"]],"start1":11403,"start2":11403,"length1":16,"length2":52}]],"length":11634,"saved":false}
{"ts":1361069544445,"patch":[[{"diffs":[[0,"   \n};\n\n"],[1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(chord, note){\n    if( note.relative ){\n        return _(chord.relNotes).contains(note.pos);\n    } else {\n        return _(chord.notes).contains(note.pos);\n    }\n};\n\n"],[0,"/** inst"]],"start1":8698,"start2":8698,"length1":16,"length2":262},{"diffs":[[0,"\n}\n\n"],[-1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(chord, note){\n    if( note.relative ){\n        return _(chord.relNotes).contains(note.pos);\n    } else {\n        return _(chord.notes).contains(note.pos);\n    }\n};"],[0,"\n\n/*"]],"start1":10736,"start2":10736,"length1":252,"length2":8}]],"length":11636,"saved":false}
{"ts":1361069844990,"patch":[[{"diffs":[[0," > 0 ){\n        "],[1,"//"],[0,"console.log( \"ma"]],"start1":2425,"start2":2425,"length1":32,"length2":34},{"diffs":[[0," 0! \");\n        "],[1,"//"],[0,"console.log(matc"]],"start1":2473,"start2":2473,"length1":32,"length2":34}]],"length":11640,"saved":false}
{"ts":1361069854058,"patch":[[{"diffs":[[0,"})\n    \n    "],[1,"//"],[0,"console.log("]],"start1":2997,"start2":2997,"length1":24,"length2":26},{"diffs":[[0,"nsnotes:\");\n    "],[1,"//"],[0,"console.log( tra"]],"start1":3027,"start2":3027,"length1":32,"length2":34}]],"length":11644,"saved":false}
{"ts":1361069899115,"patch":[[{"diffs":[[0,"ns( this"],[-1,"."],[1,","],[0," note );"]],"start1":11440,"start2":11440,"length1":17,"length2":17}]],"length":11644,"saved":false}
{"ts":1361070244750,"patch":[[{"diffs":[[0,"    if( "],[-1,"note"],[1,"chord"],[0,".relativ"]],"start1":8809,"start2":8809,"length1":20,"length2":21}]],"length":11645,"saved":false}
{"ts":1361070296532,"patch":[[{"diffs":[[0,").contains(note."],[-1,"pos"],[1,"relPos()"],[0,");\n    } else {\n"]],"start1":8866,"start2":8866,"length1":35,"length2":40}]],"length":11650,"saved":false}
