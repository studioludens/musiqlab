{"ts":1360857362073,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * the MUSIQ.js chord class\n * \n * @param notes : a simple array of integers representing the midi notes\n * @param descriptor : an object describing the chord\n * @param tonic : the current tonic Note oject\n * @param relative : if the chord should be interpreted as  relative, \n *                   i.e. can be positioned anywhere\n *                   on the musical scale (Fretboard for guitar)\n */\n\nvar Chord = function( notes, descriptor, tonic, relative ) {\n    \n    if( descriptor.hasOwnProperty( 'names') ){\n        // notes in relative position\n        this.relNotes = descriptor.notes;\n        this.names = descriptor.names;\n        this.longName = descriptor.longName;\n    }\n    // the descriptor is an array, just save the values\n    // here and \n    this.notes = notes;\n    \n    \n    // if the chord is abstract, it has no tonic.\n    if( tonic ) this.abstract = false;\n    else        this.abstract = true;\n    \n    // if the chord is relative, it can be positioned anywhere\n    // on the musical axis\n    this.relative = relative || false;\n    // override this if the tonic is relative\n    this.relative = tonic.relative;\n    \n    // this should be a Note object\n    this.tonic = tonic || new Note(0);\n};\n\n/**\n * constructs a Chord object from a notation like Cmaj7\n * \n * TODO: implement this method properly so it supports all accidentals\n */\n\nChord.fromNotation = function( name, octave ){\n    \n    var tonic;\n    var notation;\n    // set the tonic\n    if( name.indexOf('#') == 1 || name.indexOf('b') == 1 ){\n        // we have a sharp\n        tonic = Note.fromNotation(name.substring(0,2));\n        notation = name.substring(2);\n    } else {\n        // nothing special\n        tonic = Note.fromNotation(name.substring(0,1));\n        notation = name.substring(1);\n    }\n    \n    if( !notation || notation.length == 0){\n        // set the default maj notation\n        notation = 'M';\n    }\n    \n    // check if we have a valid notation and a valid tonic\n    \n    \n    \n    // get the chords that match the description.\n    \n    // this should be only one!\n    var matchedChords = _(MUSIQ.chords).filter(function(chord){\n        return _(chord.names).some(function(name){ return name == notation });\n    });\n    \n    console.log(\"matched chords for \" + notation );\n    console.log(matchedChords);\n    \n    // probably also check all alternative names for this chord\n    if( !tonic || !notation || !matchedChords || !(matchedChords.length > 0)){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }\n    \n    \n    // find the name in the chord names array\n    var chord = new Chord( matchedChords[0].notes, matchedChords[0], tonic );\n    \n    return chord;\n};\n\n/**\n * build a chord from individual notes\n * these can be note objects or just a list of integers\n * @param notes     : a simple array of integer notes\n * @param inversion : the number of the inversion, \n *                    0 = root position, 1 = first inversion, 2 = second inversion, ...\n * @returns an array of matching chords\n */\nChord.fromNotes = function( notes, inversion ){\n    \n    var ret = [];\n    \n    // make a nice array of Note objects from the notes parameter\n    var noteObjects = _.map( notes, function(note) {\n        return new Note(note);\n    });\n    \n    //console.log( \"fromNotes with inversion \" + inversion );\n    \n    if (_.isNumber(inversion) && inversion > -1) {\n        // specified an inversion, we first determine the tonic\n\n        // sort the notes from lowest to highest\n        var relNotes = notes.slice();\n\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //_.each(relNotes, function(item){console.log((new Note(item).notation()))});\n        \n        // determine the tonic - the lowest note\n        var tonic = relNotes[inversion];\n        var tonicNote = new Note(tonic);\n        //var relTonic = relNotes[0];\n\n        //var uniqueNotes = _.uniq(relNotes);\n\n        // make the notes relative to the tonic\n        relNotes = _.map(relNotes, function(note) {\n            return note - tonic;\n        });\n        \n        //console.log(relNotes);\n        \n        // wrap negative notes\n        relNotes = _.map( relNotes, function(note){\n            if( note < 0 ){\n                // move it enough octaves up\n                var n = note - (Math.floor( note / 12 ) * 12);\n                console.assert( n >= 0);\n                return n;\n            } else {\n                return note;\n            }\n        });\n        \n        //console.log(relNotes);\n        \n        // now find the chords for all the different possible inversions\n\n        //console.log(relNotes);\n\n\n        // get the notes within two octaves of the tonic\n        var relNotes = _.map(relNotes, function(note) {\n            if( note < 0 ) {\n                console.log(\"ERROR: negative note! \");\n            }\n            else if (note < 12) {\n                return note;\n            }\n            else {\n                // filter out special notes, like 9th, 11th and 13th\n                var relNote = note % 12;\n                if (MUSIQ.chordExtensionNotes.indexOf(relNote) > -1) {\n                    return relNote + 12;\n                }\n                else {\n                    return relNote;\n                }\n            }\n\n        });\n\n        //console.log(relNotes);\n        \n        \n        //console.log( relNotes );\n        // now remove duplicates\n        relNotes = _.uniq(relNotes);\n        \n        // sort the notes\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //console.log(inversion + \" : \" + tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n        \n        \n        //var foundTonics = [];\n        // find chords in the descriptor list that match\n        var matchedChordDescrs = _.filter(MUSIQ.chords, function(item) {\n            // remove the optional 5th chord\n            \n            if( item.optionalFifth ){\n                // match both to the item.notes array and the one without 7\n                // not array without the 5th (remove the 7 from the array)\n                var notesWOFifth = _.without(item.notes, 7);\n                \n                return _.isEqual(item.notes, relNotes ) || _.isEqual(notesWOFifth, relNotes);\n            } else {\n                return _.isEqual(item.notes, relNotes);\n            }\n        }, this);\n        \n        // filter duplicates\n        matchedChordDescrs = _.uniq(matchedChordDescrs);\n\n\n        // add the matched chords to the return array\n\n        var matchedChords = _.map( matchedChordDescrs, function(item){\n            return new Chord(noteObjects, item, new Note(tonic));\n        } );\n        \n        // only log this if we found a matched chord\n        if( matchedChords.length > 0){\n           // var tonicNote = new Note(tonic);\n            \n            //console.log(tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n            //console.log( \"found in inversion \" + inversion  + \"(\" + tonicNote.simpleNotation() + \") - [ \" + relNotes + \"]\");\n            //console.log(notes);\n            //console.log(relNotes);\n        }\n        \n        //console.log( matchedChords );\n        \n        return matchedChords;\n\n    }\n    // no inversion specified\n    else {\n        // simple list of chord tonics to check if we have looked for\n        // specific chords already\n        var chordTonics = [];\n        for (var i = 0; i < notes.length; i++) {\n            // add matched chords from all inversions of this chord\n            var curNote = new Note(notes[i]);\n            \n            if( chordTonics.indexOf(curNote.toRelative().pos) > -1){\n                continue;\n            }\n            \n            chordTonics.push(curNote.toRelative().pos);\n            \n            var matchedChords = Chord.fromNotes(notes, i);\n            \n            \n            ret = ret.concat(matchedChords);\n        }\n        \n        //console.log( chordTonics);\n        \n        // remove any duplicates\n        \n        \n        //console.log( ret );\n        \n        if( !(ret.length > 0) ){\n            //console.log(\"Chord not found!\");\n        }\n        return ret;\n    }\n    \n};\n\n/** instance methods **/\n\n/**\n * get the chord in proper notation\n */\nChord.prototype.notation = function() {\n    if( this.abstract ){\n        return this.names[0];\n    } else {\n        return this.tonic.simpleNotation() + this.names[0];\n    }\n};\n\n/**\n * get the name of the chord in long, readable notation\n */\nChord.prototype.longNotation = function() {\n    if( this.abstract ){\n        return this.longName;\n    } else {\n        return this.tonic.simpleNotation() + \" \" + this.longName;\n    }\n};\n\n/**\n * transpose a chard with a certain interval and return the new transposed\n * chord\n */\nChord.prototype.transpose = function(interval) {\n    // TODO; implement method\n    // transpose notes\n    this.notes = _(this.notes).map(function(note){\n        return note.transpose( interval );\n    });\n    // transpose tonic\n    this.tonic = this.tonic.transpose( interval );\n};\n\n/**\n * returns the absolute notes\n */\nChord.prototype.noteObjects = function(){\n    \n    // just return the simple list of notes\n    if( this._notes ) return this._notes;\n    \n    var allNotes =  _.map(  this.relNotes, \n                            function(note){ \n                                console.log(this.tonic.pos+note);\n                                return new Note(this.tonic.pos+note); \n                            }, this );\n    console.log(allNotes);\n    return allNotes;\n};\n\n/**\n * a simple toString function that gives us the notation of all the notes\n */\nChord.prototype.toString = function(){\n    var ret = \"[ \";\n    _.each(this.notes, function(item){ret += (new Note(item))});\n    return ret;\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":9729}]],"length":9729}
{"contributors":[],"silentsave":false,"ts":1360857381551,"patch":[[{"diffs":[[0,"    "],[-1,"// the descriptor is an array, just save the values\n    // here and"],[1,"\n   "],[0," \n  "]],"start1":687,"start2":687,"length1":75,"length2":12}]],"length":9666,"saved":false}
{"ts":1360857520148,"patch":[[{"diffs":[[0,"on];"],[-1,"\n        var tonicNote = new Note(tonic);\n        //var relTonic = relNotes[0];"],[0,"\n\n  "]],"start1":3717,"start2":3717,"length1":87,"length2":8},{"diffs":[[0,"te(tonic"],[1,", true"],[0,"));\n    "]],"start1":6471,"start2":6471,"length1":16,"length2":22}]],"length":9593,"saved":false}
{"ts":1360857544950,"patch":[[{"diffs":[[0,"    "],[-1,"// add the matched chords to the return array"],[0,"\n\n  "]],"start1":6295,"start2":6295,"length1":53,"length2":8},{"diffs":[[0,"(item){\n"],[1,"            // add the matched chords to the return array\n            // add the tonic as a relative note\n"],[0,"        "]],"start1":6364,"start2":6364,"length1":16,"length2":122}]],"length":9654,"saved":false}
{"ts":1360857945096,"patch":[[{"diffs":[[0,"ray\n"],[-1,"            // add the tonic as a relative note\n"],[0,"    "]],"start1":6426,"start2":6426,"length1":56,"length2":8},{"diffs":[[0,"onic"],[-1,", true"],[0,"));\n"]],"start1":6488,"start2":6488,"length1":14,"length2":8}]],"length":9600,"saved":false}
{"ts":1360859702598,"patch":[[{"diffs":[[0," octave ){\n    \n"],[1,"    // check if it's a valid notation, at least the note part\n    \n    \n    \n"],[0,"    var tonic;\n "]],"start1":1334,"start2":1334,"length1":32,"length2":109},{"diffs":[[0," var tonic;\n"],[-1,""],[0,"    var nota"]],"start1":1430,"start2":1430,"length1":24,"length2":24},{"diffs":[[0," tonic\n    \n"],[-1,"    \n    \n"],[0,"    // get t"]],"start1":1978,"start2":1978,"length1":34,"length2":24},{"diffs":[[0,"return;\n"],[1,""],[0,"    }\n  "]],"start1":2524,"start2":2524,"length1":16,"length2":16},{"diffs":[[0,"\n    }\n    \n"],[-1,"    \n"],[0,"    // find "]],"start1":2531,"start2":2531,"length1":29,"length2":24}]],"length":9662,"saved":false}
{"ts":1360861826815,"patch":[[{"diffs":[[0,"rt\n    \n    "],[1,"var regex = /^([A-G]|[a-g])(bbb|bb|b|#|##)? ?(maj7|M|maj|dim|major 7|major|m)?$/;\n    var matches = regex.exec( name );\n    console.log(matches);"],[0,"\n    \n    va"]],"start1":1409,"start2":1409,"length1":24,"length2":169}]],"length":9807,"saved":false}
{"ts":1360861963349,"patch":[[{"diffs":[[0,"ajor|m)?"],[1," ?(chord)?"],[0,"$/;\n    "]],"start1":1491,"start2":1491,"length1":16,"length2":26}]],"length":9817,"saved":false}
{"ts":1360862004769,"patch":[[{"diffs":[[0,"ec( name );\n"],[1,"    console.log(\"Matches:\");\n"],[0,"    console."]],"start1":1539,"start2":1539,"length1":24,"length2":53}]],"length":9846,"saved":false}
{"ts":1360862155788,"patch":[[{"diffs":[[0,"hord)?$/"],[1,"m"],[0,";\n    va"]],"start1":1503,"start2":1503,"length1":16,"length2":17}]],"length":9847,"saved":false}
{"ts":1360862424559,"patch":[[{"diffs":[[0,"regex = "],[-1,"/"],[1,"new RegExp(\""],[0,"^([A-G]|"]],"start1":1425,"start2":1425,"length1":17,"length2":28},{"diffs":[[0,"d)?$"],[-1,"/m"],[1,"\",\"m\")"],[0,";\n  "]],"start1":1517,"start2":1517,"length1":10,"length2":14}]],"length":9862,"saved":false}
{"ts":1360862942205,"patch":[[{"diffs":[[0,"e part\n    \n"],[1,"    var chordNames = _(MUSIQ.chords).reduce(function(c){\n        console.log(c);\n    })\n"],[0,"    var rege"]],"start1":1405,"start2":1405,"length1":24,"length2":112},{"diffs":[[0,"? ?("],[-1,"maj7|M|maj|dim|major 7|major|m"],[1,"\"+ chordNames + \""],[0,")? ?"]],"start1":1562,"start2":1562,"length1":38,"length2":25}]],"length":9937,"saved":false}
{"ts":1360862947863,"patch":[[{"diffs":[[0,";\n    })"],[1,";\n    "],[0,"\n    var"]],"start1":1496,"start2":1496,"length1":16,"length2":22}]],"length":9943,"saved":false}
{"ts":1360863181789,"patch":[[{"diffs":[[0,"unction("],[-1,"c"],[1,"memo, item"],[0,"){\n     "]],"start1":1462,"start2":1462,"length1":17,"length2":26},{"diffs":[[0,"    "],[-1,"console.log(c)"],[1,"memo += \"|\" + item.names.join(\"|\") + \"|\" + item.longName"],[0,";\n  "]],"start1":1487,"start2":1487,"length1":22,"length2":64}]],"length":9994,"saved":false}
{"ts":1360863199356,"patch":[[{"diffs":[[0,"e;\n    });\n    \n"],[1,"    console.log(chordNames);\n    \n"],[0,"    var regex = "]],"start1":1546,"start2":1546,"length1":32,"length2":66}]],"length":10028,"saved":false}
{"ts":1360863242785,"patch":[[{"diffs":[[0,"emo, item){\n"],[1,"        console.log(item);\n"],[0,"        memo"]],"start1":1471,"start2":1471,"length1":24,"length2":51}]],"length":10055,"saved":false}
{"ts":1360863576766,"patch":[[{"diffs":[[0,"    "],[1,"return "],[0,"memo +"],[-1,"="],[0," \"|\""]],"start1":1514,"start2":1514,"length1":15,"length2":21}]],"length":10061,"saved":false}
{"ts":1360863588482,"patch":[[{"diffs":[[0,"ole.log("],[-1,"it"],[1,"m"],[0,"em"],[1,"o"],[0,");\n     "]],"start1":1495,"start2":1495,"length1":20,"length2":20}]],"length":10061,"saved":false}
{"ts":1360863748141,"patch":[[{"diffs":[[0,"    "],[-1,"console.log(memo)"],[1,"var m = _(memo).isString() ? memo : memo.names.join(\"|\") + \"|\" + memo.longName"],[0,";\n  "]],"start1":1487,"start2":1487,"length1":25,"length2":86},{"diffs":[[0,"return m"],[-1,"emo"],[0," + \"|\" +"]],"start1":1579,"start2":1579,"length1":19,"length2":16}]],"length":10119,"saved":false}
{"ts":1360863769924,"patch":[[{"diffs":[[0,"emo, item){\n"],[1,"        console.log(m);\n"],[0,"        var "]],"start1":1471,"start2":1471,"length1":24,"length2":48},{"diffs":[[0,"o.longName;\n"],[1,"        console.log(m);\n"],[0,"        retu"]],"start1":1583,"start2":1583,"length1":24,"length2":48}]],"length":10167,"saved":false}
{"ts":1360863772089,"patch":[[{"diffs":[[0,"m){\n"],[-1,"        console.log(m);\n"],[0,"    "]],"start1":1479,"start2":1479,"length1":32,"length2":8}]],"length":10143,"saved":false}
{"ts":1360863938271,"patch":[[{"diffs":[[0,"ngName;\n        "],[1,"//"],[0,"console.log(m);\n"]],"start1":1563,"start2":1563,"length1":32,"length2":34}]],"length":10145,"saved":false}
{"ts":1360864299222,"patch":[[{"diffs":[[0,"optional"],[-1,"Fifth"],[0," ){\n    "]],"start1":6290,"start2":6290,"length1":21,"length2":16}]],"length":10140,"saved":false}
{"ts":1360864322984,"patch":[[{"diffs":[[0,"t match\n"],[1,"        \n        \n"],[0,"        "]],"start1":6130,"start2":6130,"length1":16,"length2":34},{"diffs":[[0,"rd\n            \n"],[1,"            // TODO: change this so it can optionally remove any note and\n            // still match\n"],[0,"            if( "]],"start1":6271,"start2":6271,"length1":32,"length2":133}]],"length":10259,"saved":false}
{"ts":1360864590976,"patch":[[{"diffs":[[0," still match"],[1,", not only 5th, but also 7th, 9th and 11th"],[0,"\n           "]],"start1":6375,"start2":6375,"length1":24,"length2":66}]],"length":10301,"saved":false}
{"ts":1360864662291,"patch":[[{"diffs":[[0,"var "],[-1,"chordNam"],[1,"match"],[0,"es = "],[-1,"_("],[0,"MUSIQ."],[-1,"chords).reduce(function(memo, item){\n        var m = _(memo).isString() ? memo : memo.names.join(\"|\") + \"|\" + memo.longName;\n        //console.log(m);\n        return m + \"|\" + item.names.join(\"|\") + \"|\" + item.longName;\n    });\n    \n    console.log(chordNames);\n    \n    var regex = new RegExp(\"^([A-G]|[a-g])(bbb|bb|b|#|##)? ?(\"+ chordNames + \")? ?(chord)?$\",\"m\");\n    var matches = regex.exec( name );\n    console.log(\"Matches:\");\n    console.log(matches"],[1,"isValidChord( name "],[0,");\n "]],"start1":1421,"start2":1421,"length1":485,"length2":43}]],"length":9859,"saved":false}
{"ts":1360864800722,"patch":[[{"diffs":[[0,"    "],[-1,"var tonic;\n    var notation;\n    // set the tonic\n    if( name.indexOf('#') == 1 || name.indexOf('b') == 1 ){\n        // we have a sharp\n        tonic = Note.fromNotation(name.substring(0,2));\n        notation = name.substring(2);\n    } else {"],[1,"// no chord found?\n    if( !matches ){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }"],[0,"\n    "],[-1,"    // nothing special\n        tonic = Note.fromNotation(name.substring(0,1))"],[1,"\n    var tonic"],[0,";\n    "],[-1,"   "],[1,"var"],[0," not"]],"start1":1468,"start2":1468,"length1":342,"length2":147},{"diffs":[[0,"tion"],[-1," = name.substring(1)"],[0,";\n    "],[-1,"}"],[0,"\n   "]],"start1":1616,"start2":1616,"length1":35,"length2":14},{"diffs":[[0,"   \n"],[-1,"    // check if we have a valid notation and a valid tonic\n    \n    // get the chords that match the description.\n    \n"],[0,"    "]],"start1":1747,"start2":1747,"length1":127,"length2":8},{"diffs":[[0,"    "],[-1,"\n    // probably also check all alternative names for this chord\n    if( !tonic || !notation || !matchedChords || !(matchedChords.length > 0)){\n        console.warn(\"Chord not found : \" + name);\n        return;\n    }"],[1,""],[0,"\n   "]],"start1":2023,"start2":2023,"length1":224,"length2":8}]],"length":9308,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360864933706,"patch":[[{"diffs":[[0,"Notes);\n"],[-1,"        \n        "],[0,"\n       "]],"start1":4717,"start2":4717,"length1":33,"length2":16},{"diffs":[[0,"\");\n"],[-1,"        \n        \n        //var foundTonics = [];"],[0,"\n   "]],"start1":5017,"start2":5017,"length1":57,"length2":8},{"diffs":[[0,"t match\n"],[-1,"        \n        \n"],[0,"        "]],"start1":5071,"start2":5071,"length1":34,"length2":16}]],"length":9224,"saved":false}
{"ts":1360867411838,"patch":[[{"diffs":[[0,"ame );\n    \n"],[1,"    console.log( matches );\n    \n"],[0,"    // no ch"]],"start1":1456,"start2":1456,"length1":24,"length2":57},{"diffs":[[0,"   var tonic"],[-1,";"],[1," = matches"],[0,"\n    var not"]],"start1":1623,"start2":1623,"length1":25,"length2":34}]],"length":9266,"saved":false}
{"ts":1360867472269,"patch":[[{"diffs":[[0,"tonic = "],[-1,"matches"],[1,"Note.fromNotation( matches[1] + matches[2] );"],[0,"\n    var"]],"start1":1630,"start2":1630,"length1":23,"length2":61},{"diffs":[[0,"notation"],[1," = matches[3]"],[0,";\n    \n "]],"start1":1692,"start2":1692,"length1":16,"length2":29}]],"length":9317,"saved":false}
{"ts":1360867879626,"patch":[[{"diffs":[[0,"lidChord"],[1,"Notation"],[0,"( name )"]],"start1":1445,"start2":1445,"length1":16,"length2":24}]],"length":9325,"saved":false}
{"ts":1360868030981,"patch":[[{"diffs":[[0,"tches[2] );\n"],[1,"    console.log( tonic );\n"],[0,"    var nota"]],"start1":1680,"start2":1680,"length1":24,"length2":50}]],"length":9351,"saved":false}
{"ts":1360868083115,"patch":[[{"diffs":[[0,"on = 'M';\n    }\n"],[1,"    console.log( notation );\n"],[0,"    \n    // this"]],"start1":1857,"start2":1857,"length1":32,"length2":61}]],"length":9380,"saved":false}
{"ts":1360868135333,"patch":[[{"diffs":[[0,"es[1] + "],[1,"("],[0,"matches["]],"start1":1670,"start2":1670,"length1":16,"length2":17},{"diffs":[[0,"tches[2]"],[1," || \"\")"],[0," );\n    "]],"start1":1681,"start2":1681,"length1":16,"length2":23}]],"length":9388,"saved":false}
{"ts":1360868223621,"patch":[[{"diffs":[[0,"ords);\n    \n"],[1,"    // we should check that the specific notation does not match\n    // more than 1 chord. if so, the definition in MUSIQ.chords \n    // contains duplicates\n    console.assert( matchedChords.length == 1);\n"],[0,"    \n    // "]],"start1":2180,"start2":2180,"length1":24,"length2":229}]],"length":9593,"saved":false}
{"ts":1360868237978,"patch":[[{"diffs":[[0,"notation );\n    "],[1,"//"],[0,"console.log(matc"]],"start1":2143,"start2":2143,"length1":32,"length2":34}]],"length":9595,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360868546990,"patch":[[{"diffs":[[0,"] || \"\") );\n    "],[1,"//"],[0,"console.log( ton"]],"start1":1688,"start2":1688,"length1":32,"length2":34}]],"length":9597,"saved":false}
{"ts":1360868732826,"patch":[[{"diffs":[[0,"rn ret;\n};\n\n"],[1,"\n/**\n * the plural class, simply to expose some functions in a more\n * logical way\n */\nvar Chords = {};\nChords.fromNotation = Chord.fromNotation;\n\n"]],"start1":9585,"start2":9585,"length1":12,"length2":159}]],"length":9744,"saved":false}
{"ts":1360868861000,"patch":[[{"diffs":[[0,"s = {};\n"],[1,"Chords.fromNotes = Chord.fromNotes;\n"],[0,"Chords.f"]],"start1":9693,"start2":9693,"length1":16,"length2":52}]],"length":9780,"saved":false}
{"ts":1360869491890,"patch":[[{"diffs":[[0,"lidChord"],[-1,"Notation"],[0,"( name )"]],"start1":1445,"start2":1445,"length1":24,"length2":16}]],"length":9772,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360880587230,"patch":[[{"diffs":[[0,"lNotes;\n};\n\n"],[1,"/**\n * check if the chord can be described by a simple name\n */\nChord.prototype.hasName = function(name){\n    return _(this.names).find(function(n){\n        return name = n;\n    });\n}\n\n"],[0,"/**\n * a sim"]],"start1":9351,"start2":9351,"length1":24,"length2":209}]],"length":9957,"saved":false}
{"ts":1360880594246,"patch":[[{"diffs":[[0,"n name ="],[1,"="],[0," n;\n    "]],"start1":9525,"start2":9525,"length1":16,"length2":17}]],"length":9958,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360888541169,"patch":[[{"diffs":[[0,"r.longName;\n"],[1,"        \n        this.name = this.names[0];\n"],[0,"    }\n    \n "]],"start1":669,"start2":669,"length1":24,"length2":68}]],"length":10002,"saved":false}
{"ts":1360889772725,"patch":[[{"diffs":[[0,"ame );\n    \n    "],[1,"//"],[0,"console.log( mat"]],"start1":1500,"start2":1500,"length1":32,"length2":34}]],"length":10004,"saved":false}
{"ts":1360889783218,"patch":[[{"diffs":[[0,";\n    }\n    "],[1,"//"],[0,"console.log("]],"start1":1913,"start2":1913,"length1":24,"length2":26},{"diffs":[[0,");\n    \n    "],[1,"//"],[0,"console.log("]],"start1":2137,"start2":2137,"length1":24,"length2":26}]],"length":10008,"saved":false}
{"ts":1360893472537,"patch":[[{"diffs":[[0,"== 1);\n    \n"],[1,"    // get the transposed notes\n    var transNotes = _(matchedChords[0].notes).map(function(note){\n        return (new Note(note)).transpose(tonic.pos).pos;\n    })\n    \n"],[0,"    // find "]],"start1":2436,"start2":2436,"length1":24,"length2":193}]],"length":10177,"saved":false}
{"ts":1360893498589,"patch":[[{"diffs":[[0,"ic.pos)."],[-1,"pos"],[1,"toRelative()"],[0,";\n    })"]],"start1":2592,"start2":2592,"length1":19,"length2":28}]],"length":10186,"saved":false}
{"ts":1360893519958,"patch":[[{"diffs":[[0,"    })\n    \n"],[1,"    console.log(\"Transnotes:\");\n    console.log( transNotes ); \n    \n"],[0,"    // find "]],"start1":2614,"start2":2614,"length1":24,"length2":93}]],"length":10255,"saved":false}
{"ts":1360893531082,"patch":[[{"diffs":[[0," Chord( "],[-1,"matchedChords[0].n"],[1,"transN"],[0,"otes, ma"]],"start1":2760,"start2":2760,"length1":34,"length2":22}]],"length":10243,"saved":false}
{"ts":1360893823709,"patch":[[{"diffs":[[0,"lative()"],[1,".pos"],[0,";\n    })"]],"start1":2604,"start2":2604,"length1":16,"length2":20}]],"length":10247,"saved":false}
{"ts":1360894317226,"patch":[[{"diffs":[[0,"       \n        "],[1,"//"],[0,"this.name = this"]],"start1":682,"start2":682,"length1":32,"length2":34}]],"length":10249,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360902550635,"patch":[[{"diffs":[[0,"et;\n};\n\n"],[1,"/**\n * the minimal notes needed to form this chord\n * @returns an array with the notes that are minimally necessary\n * to form this chord\n */\nChord.prototype.minNotes = function(){\n    \n    return _(this.notes).filter(function(note){\n        return !_(this.optional).contains(note);\n    });\n}\n\nChord.prototype.type = function(){\n    return \"Chord\";\n}\n\n"],[0,"\n/**\n * "]],"start1":10058,"start2":10058,"length1":16,"length2":368}]],"length":10601,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361037342547,"patch":[[{"diffs":[[0,"his.names[0]"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    } else"]],"start1":8438,"start2":8438,"length1":24,"length2":59},{"diffs":[[0," + this.names[0]"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    }\n};\n\n/**\n"]],"start1":8542,"start2":8542,"length1":32,"length2":67},{"diffs":[[0,"his.longName"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    } else"]],"start1":8754,"start2":8754,"length1":24,"length2":59},{"diffs":[[0,"his.longName"],[1,".replace(\"b\",\"♭\").replace(\"#\",\"♯\");"],[0,";\n    }\n};\n\n"]],"start1":8868,"start2":8868,"length1":24,"length2":59},{"diffs":[[0," absolute notes\n"],[1," * \n * save it in a local variable _notes for easy access\n"],[0," */\nChord.protot"]],"start1":9319,"start2":9319,"length1":32,"length2":90},{"diffs":[[0,"    "],[-1,"var allN"],[1,"this._n"],[0,"otes"]],"start1":9535,"start2":9535,"length1":16,"length2":15},{"diffs":[[0,"ole.log("],[-1,"allN"],[1,"\"NoteObjects\");\n    console.log(this._n"],[0,"otes);\n "]],"start1":9807,"start2":9807,"length1":20,"length2":55},{"diffs":[[0,"urn "],[-1,"allN"],[1,"this._n"],[0,"otes"]],"start1":9868,"start2":9868,"length1":12,"length2":15}]],"length":10836,"saved":false}
{"ts":1361037883574,"patch":[[{"diffs":[[0," duplicates\n"],[1,"    if( matchedChords.length > 0 ){\n        console.log( \"matched Chords > 0! \");\n        console.log(matchedChords);\n    }\n"],[0,"    console."]],"start1":2385,"start2":2385,"length1":24,"length2":148}]],"length":10960,"saved":false}
{"ts":1361038140357,"patch":[[{"diffs":[[0," = _"],[1,"(item.notes)"],[0,".wi"],[1,"d"],[0,"thout("],[-1,"item.notes, 7"],[1,"7);\n                console.log( notesWOFifth "],[0,");\n "]],"start1":6349,"start2":6349,"length1":30,"length2":76}]],"length":11006,"saved":false}
{"ts":1361038144985,"patch":[[{"diffs":[[0,"otes).wi"],[-1,"d"],[0,"thout(7)"]],"start1":6360,"start2":6360,"length1":17,"length2":16}]],"length":11005,"saved":false}
{"ts":1361038250404,"patch":[[{"diffs":[[0,"s + \" ]\");\n\n"],[1,"        console.log(\"Check descriptors\");\n        \n"],[0,"        // f"]],"start1":5790,"start2":5790,"length1":24,"length2":75}]],"length":11056,"saved":false}
{"ts":1361038323798,"patch":[[{"diffs":[[0,"WOFifth "],[1,"+ \" - \" + relNotes "],[0,");\n     "]],"start1":6463,"start2":6463,"length1":16,"length2":35}]],"length":11075,"saved":false}
{"ts":1361038515456,"patch":[[{"diffs":[[0,"scrs = _"],[-1,".filter"],[0,"(MUSIQ.c"]],"start1":5936,"start2":5936,"length1":23,"length2":16},{"diffs":[[0,"Q.chords"],[-1,", "],[1,").filter("],[0,"function"]],"start1":5949,"start2":5949,"length1":18,"length2":25}]],"length":11075,"saved":false}
{"ts":1361038528227,"patch":[[{"diffs":[[0,"b; });\n\n        "],[-1,"//"],[0,"console.log(inve"]],"start1":5696,"start2":5696,"length1":34,"length2":32}]],"length":11073,"saved":false}
{"ts":1361038577055,"patch":[[{"diffs":[[0,"unction("],[-1,"item"],[1,"chord"],[0,") {\n    "]],"start1":5965,"start2":5965,"length1":20,"length2":21},{"diffs":[[0,"fth = _("],[-1,"item"],[1,"chord"],[0,".notes)."]],"start1":6396,"start2":6396,"length1":20,"length2":21},{"diffs":[[0,"eturn _.isEqual("],[-1,"item"],[1,"chord"],[0,".notes, relNotes"]],"start1":6527,"start2":6527,"length1":36,"length2":37},{"diffs":[[0,"isEqual("],[-1,"item"],[1,"chord"],[0,".notes, "]],"start1":6651,"start2":6651,"length1":20,"length2":21}]],"length":11077,"saved":false}
{"ts":1361038735137,"patch":[[{"diffs":[[0," \" +"],[-1," tonicNote.simpleNotation() +"],[0," \" ["]],"start1":5739,"start2":5739,"length1":37,"length2":8}]],"length":11048,"saved":false}
{"ts":1361038755441,"patch":[[{"diffs":[[0,"    if( "],[-1,"item"],[1,"chord"],[0,".optiona"]],"start1":6162,"start2":6162,"length1":20,"length2":21}]],"length":11049,"saved":false}
{"ts":1361039297139,"patch":[[{"diffs":[[0,"fth = _("],[-1,"chord.n"],[1,"relN"],[0,"otes).wi"]],"start1":6368,"start2":6368,"length1":23,"length2":20},{"diffs":[[0,"without("],[-1,"7"],[1,"chord.optional"],[0,");\n     "]],"start1":6386,"start2":6386,"length1":17,"length2":30},{"diffs":[[0,"h + \" - \" + "],[-1,"relN"],[1,"chord.n"],[0,"otes );\n    "]],"start1":6451,"start2":6451,"length1":28,"length2":31}]],"length":11062,"saved":false}
{"ts":1361039360568,"patch":[[{"diffs":[[0,"    return _"],[-1,".isEqual"],[0,"(chord.notes"]],"start1":6507,"start2":6507,"length1":32,"length2":24},{"diffs":[[0,"rn _(chord.notes"],[-1,", "],[1,").isEqual("],[0,"relNotes ) || _."]],"start1":6515,"start2":6515,"length1":34,"length2":42},{"diffs":[[0,"s ) || _"],[1,"(chord.notes)"],[0,".isEqual"]],"start1":6548,"start2":6548,"length1":16,"length2":29},{"diffs":[[0,"sWOFifth"],[-1,", relNotes"],[0,");\n     "]],"start1":6582,"start2":6582,"length1":26,"length2":16}]],"length":11065,"saved":false}
{"ts":1361039398544,"patch":[[{"diffs":[[0,"return _"],[-1,".isEqual"],[0,"(chord.n"]],"start1":6630,"start2":6630,"length1":24,"length2":16},{"diffs":[[0,"rd.notes"],[-1,", "],[1,").isEqual("],[0,"relNotes"]],"start1":6642,"start2":6642,"length1":18,"length2":26}]],"length":11065,"saved":false}
{"ts":1361039427295,"patch":[[{"diffs":[[0," // "],[-1,"match both to the item.notes array and the one without 7\n                // not array without the 5th (remove the 7 from th"],[1,"remove all optional notes from the sourc"],[0,"e array"],[-1,")"],[0,"\n   "]],"start1":6203,"start2":6203,"length1":139,"length2":55},{"diffs":[[0,"ional);\n"],[1,"                \n"],[0,"        "]],"start1":6319,"start2":6319,"length1":16,"length2":33}]],"length":10998,"saved":false}
{"ts":1361039497648,"patch":[[{"diffs":[[0,"es)."],[-1,"without"],[1,"difference"],[0,"(cho"]],"start1":6298,"start2":6298,"length1":15,"length2":18}]],"length":11001,"saved":false}
{"ts":1361039548973,"patch":[[{"diffs":[[0,"    "],[-1,"// remove the optional 5th chord\n            \n            // TODO: change this so it can optionally remove any note and\n            // still match, not only 5th, but also 7th, 9th and 11th"],[1,"\n            "],[0,"\n   "]],"start1":5961,"start2":5961,"length1":196,"length2":21},{"diffs":[[0,"ar notes"],[-1,"WOFifth"],[1,"Req"],[0," = _(rel"]],"start1":6097,"start2":6097,"length1":23,"length2":19},{"diffs":[[0,"g( notes"],[-1,"WOFifth"],[1,"Req"],[0," + \" - \""]],"start1":6194,"start2":6194,"length1":23,"length2":19},{"diffs":[[0,"otes"],[-1,"WOFifth"],[1,"Req"],[0,");\n "]],"start1":6332,"start2":6332,"length1":15,"length2":11}]],"length":10814,"saved":false}
{"ts":1361039568258,"patch":[[{"diffs":[[0,"ource array\n"],[1,"                \n                // so we're only left with the absolute required notes to form this chord\n"],[0,"            "]],"start1":6068,"start2":6068,"length1":24,"length2":131}]],"length":10921,"saved":false}
{"ts":1361040099427,"patch":[[{"diffs":[[0,"    "],[-1,"var transNotes = _(matchedChords[0].n"],[1,"\n    // first add any optional notes\n    var allNotes = matchedChords[0].optional ?\n                      _(matchedChords[0].notes).union(matchedChords[0].optional).sort(function(a, b) { return a - b; })\n                    : matchedChords[0].notes;\n    \n    var transNotes = _(allN"],[0,"otes"]],"start1":2606,"start2":2606,"length1":45,"length2":290}]],"length":11166,"saved":false}
{"ts":1361040403126,"patch":[[{"diffs":[[0,"ional);\n"],[1,"                var chordNotesReq = _(chord.notes).difference(chord.optional);\n"],[0,"        "]],"start1":6495,"start2":6495,"length1":16,"length2":95},{"diffs":[[0,"               \n"],[-1,""],[0,"                "]],"start1":6583,"start2":6583,"length1":32,"length2":32},{"diffs":[[0,"  return _(chord"],[-1,".n"],[1,"N"],[0,"otes"],[1,"Req"],[0,").isEqual(relNot"]],"start1":6693,"start2":6693,"length1":38,"length2":40},{"diffs":[[0,"tes ) || _(chord"],[-1,".n"],[1,"N"],[0,"otes"],[1,"Req"],[0,").isEqual(notesR"]],"start1":6732,"start2":6732,"length1":38,"length2":40}]],"length":11249,"saved":false}
{"ts":1361040606283,"patch":[[{"diffs":[[0,"                "],[1,"//"],[0,"console.log( not"]],"start1":6599,"start2":6599,"length1":32,"length2":34}]],"length":11251,"saved":false}
{"ts":1361042502388,"patch":[[{"diffs":[[0,"b; });\n\n        "],[1,"//"],[0,"console.log(inve"]],"start1":5941,"start2":5941,"length1":32,"length2":34},{"diffs":[[0,"\" ]\");\n\n        "],[1,"//"],[0,"console.log(\"Che"]],"start1":6010,"start2":6010,"length1":32,"length2":34}]],"length":11255,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069072948,"patch":[[{"diffs":[[0," });\n}\n\n"],[1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(note){\n    if( note.relative ){\n        return _(relNotes)\n    } else {\n        \n    }\n    \n}\n\n"],[0,"/**\n * a"]],"start1":10486,"start2":10486,"length1":16,"length2":192}]],"length":11431,"saved":false}
{"ts":1361069099728,"patch":[[{"diffs":[[0,"eturn _("],[1,"this."],[0,"relNotes"]],"start1":10616,"start2":10616,"length1":16,"length2":21},{"diffs":[[0,"elNotes)"],[1,".contains(note.pos);"],[0,"\n    } e"]],"start1":10630,"start2":10630,"length1":16,"length2":36},{"diffs":[[0,"e {\n        "],[1,"return _(this.notes).contains(note.pos);"],[0,"\n    }\n    \n"]],"start1":10668,"start2":10668,"length1":24,"length2":64}]],"length":11496,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069496948,"patch":[[{"diffs":[[0,"ains = function("],[-1,""],[0,""],[1,"chord, "],[0,"note){\n    if( n"]],"start1":10559,"start2":10559,"length1":32,"length2":39},{"diffs":[[0,"eturn _("],[-1,"this"],[1,"chord"],[0,".relNote"]],"start1":10623,"start2":10623,"length1":20,"length2":21},{"diffs":[[0,"       return _("],[-1,"this"],[1,"chord"],[0,".notes).contains"]],"start1":10681,"start2":10681,"length1":36,"length2":37},{"diffs":[[0,";\n    }\n"],[-1,"    \n"],[0,"}"],[1,";"],[0,"\n\n/**\n *"]],"start1":10728,"start2":10728,"length1":22,"length2":18},{"diffs":[[0,"rd\";\n}\n\n"],[1,"/**\n * check if a Chord contains a note\n */\nChord.prototype.contains = function( note ){\n    \n}\n\n"],[0,"\n/**\n * "]],"start1":11310,"start2":11310,"length1":16,"length2":113}]],"length":11598,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361069524775,"patch":[[{"diffs":[[0," ){\n    "],[1,"return Chord.contains( this. note );"],[0,"\n}\n\n\n/**"]],"start1":11403,"start2":11403,"length1":16,"length2":52}]],"length":11634,"saved":false}
{"ts":1361069544445,"patch":[[{"diffs":[[0,"   \n};\n\n"],[1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(chord, note){\n    if( note.relative ){\n        return _(chord.relNotes).contains(note.pos);\n    } else {\n        return _(chord.notes).contains(note.pos);\n    }\n};\n\n"],[0,"/** inst"]],"start1":8698,"start2":8698,"length1":16,"length2":262},{"diffs":[[0,"\n}\n\n"],[-1,"/**\n * check if this chord contains a certain note\n */\nChord.contains = function(chord, note){\n    if( note.relative ){\n        return _(chord.relNotes).contains(note.pos);\n    } else {\n        return _(chord.notes).contains(note.pos);\n    }\n};"],[0,"\n\n/*"]],"start1":10736,"start2":10736,"length1":252,"length2":8}]],"length":11636,"saved":false}
{"ts":1361069844990,"patch":[[{"diffs":[[0," > 0 ){\n        "],[1,"//"],[0,"console.log( \"ma"]],"start1":2425,"start2":2425,"length1":32,"length2":34},{"diffs":[[0," 0! \");\n        "],[1,"//"],[0,"console.log(matc"]],"start1":2473,"start2":2473,"length1":32,"length2":34}]],"length":11640,"saved":false}
{"ts":1361069854058,"patch":[[{"diffs":[[0,"})\n    \n    "],[1,"//"],[0,"console.log("]],"start1":2997,"start2":2997,"length1":24,"length2":26},{"diffs":[[0,"nsnotes:\");\n    "],[1,"//"],[0,"console.log( tra"]],"start1":3027,"start2":3027,"length1":32,"length2":34}]],"length":11644,"saved":false}
{"ts":1361069899115,"patch":[[{"diffs":[[0,"ns( this"],[-1,"."],[1,","],[0," note );"]],"start1":11440,"start2":11440,"length1":17,"length2":17}]],"length":11644,"saved":false}
{"ts":1361070244750,"patch":[[{"diffs":[[0,"    if( "],[-1,"note"],[1,"chord"],[0,".relativ"]],"start1":8809,"start2":8809,"length1":20,"length2":21}]],"length":11645,"saved":false}
{"ts":1361070296532,"patch":[[{"diffs":[[0,").contains(note."],[-1,"pos"],[1,"relPos()"],[0,");\n    } else {\n"]],"start1":8866,"start2":8866,"length1":35,"length2":40}]],"length":11650,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361206285991,"patch":[[{"diffs":[[0,");\n\n"],[-1,"\n        \n\n"],[0,"    "]],"start1":6993,"start2":6993,"length1":19,"length2":8}]],"length":11639,"saved":false}
{"ts":1361206940899,"patch":[[{"diffs":[[0,"urn "],[-1,"\"Chord\""],[1,"this.type"],[0,";\n}\n"]],"start1":11307,"start2":11307,"length1":15,"length2":17}]],"length":11641,"saved":false}
{"ts":1361206970931,"patch":[[{"diffs":[[0,"guitar)\n"],[1," * @param type : the type of chord\n"],[0," */\n\nvar"]],"start1":391,"start2":391,"length1":16,"length2":51},{"diffs":[[0,"relative"],[1,", type"],[0," ) {\n   "]],"start1":487,"start2":487,"length1":16,"length2":22},{"diffs":[[0,"ote(0);\n"],[1,"    \n    this.type = type || \"Chord\";\n"],[0,"};\n\n/**\n"]],"start1":1233,"start2":1233,"length1":16,"length2":54}]],"length":11720,"saved":false}
{"ts":1361206991741,"patch":[[{"diffs":[[0,"  \n    this."],[1,"_"],[0,"type = type "]],"start1":1243,"start2":1243,"length1":24,"length2":25}]],"length":11721,"saved":false}
{"ts":1361206997924,"patch":[[{"diffs":[[0,"rn this."],[1,"_"],[0,"type;\n}\n"]],"start1":11388,"start2":11388,"length1":16,"length2":17}]],"length":11722,"saved":false}
{"ts":1361207201736,"patch":[[{"diffs":[[0,"\n * "],[-1,"TODO: implement this method properly so it supports all accidentals"],[0,"\n */\n"],[-1,"\n"],[0,"Chor"]],"start1":1347,"start2":1347,"length1":81,"length2":13}]],"length":11654,"saved":false}
{"ts":1361207285487,"patch":[[{"diffs":[[0,"ke Cmaj7\n * "],[1,"@name : the chord name\n * @type : the chord type, can be 'chord' or 'scale'"],[0,"\n * \n */\nCho"]],"start1":1335,"start2":1335,"length1":24,"length2":99},{"diffs":[[0,"( name, "],[-1,"octav"],[1,"typ"],[0,"e ){\n   "]],"start1":1460,"start2":1460,"length1":21,"length2":19}]],"length":11727,"saved":false}
{"ts":1361207331071,"patch":[[{"diffs":[[0,"    "],[-1,"\n    var matches = MUSIQ.isValidChord( name );"],[1,"var matches;\n    \n    if( type == 'chord' ){\n        matches = MUSIQ.isValidChord( name );\n    } else if( type == 'scale'){\n        matches = MUSIQ.isValidScale( name );\n    }"],[0,"\n   "]],"start1":1543,"start2":1543,"length1":54,"length2":183}]],"length":11856,"saved":false}
{"ts":1361207378894,"patch":[[{"diffs":[[0,"tches;\n    \n"],[1,"    // the array used to look up chords\n    var lookup;\n    \n"],[0,"    if( type"]],"start1":1553,"start2":1553,"length1":24,"length2":85},{"diffs":[[0,"rd( name );\n"],[1,"        lookup = MUSIQ.chords;\n"],[0,"    } else i"]],"start1":1687,"start2":1687,"length1":24,"length2":55},{"diffs":[[0,"dChords = _("],[-1,"MUSIQ.chords"],[0,").filter(fun"]],"start1":2311,"start2":2311,"length1":36,"length2":24}]],"length":11936,"saved":false}
{"ts":1361207410790,"patch":[[{"diffs":[[0,"ype == '"],[-1,"chord' "],[1,"scale'"],[0,"){\n     "]],"start1":1635,"start2":1635,"length1":23,"length2":22},{"diffs":[[0,".isValid"],[-1,"Chord"],[1,"Scale"],[0,"( name )"]],"start1":1675,"start2":1675,"length1":21,"length2":21},{"diffs":[[0," } else "],[-1,"if( type == 'scale'){"],[1,"{\n        // default to chord"],[0,"\n       "]],"start1":1732,"start2":1732,"length1":37,"length2":45},{"diffs":[[0," = MUSIQ.isValid"],[-1,"Scale"],[1,"Chord"],[0,"( name );\n    }\n"]],"start1":1785,"start2":1785,"length1":37,"length2":37},{"diffs":[[0,"rd( name );\n"],[1,"        lookup = MUSIQ.chords;\n"],[0,"    }\n    \n "]],"start1":1804,"start2":1804,"length1":24,"length2":55}]],"length":11974,"saved":false}
{"ts":1361207416587,"patch":[[{"diffs":[[0," lookup = MUSIQ."],[-1,"chord"],[1,"scale"],[0,"s;\n    } else {\n"]],"start1":1705,"start2":1705,"length1":37,"length2":37}]],"length":11974,"saved":false}
{"ts":1361207434165,"patch":[[{"diffs":[[0,"rds = _("],[1,"lookup"],[0,").filter"]],"start1":2353,"start2":2353,"length1":16,"length2":22}]],"length":11980,"saved":false}
{"ts":1361207473725,"patch":[[{"diffs":[[0,"ds[0], tonic"],[1,", false, chordType"],[0," );\n    \n   "]],"start1":3512,"start2":3512,"length1":24,"length2":42}]],"length":11998,"saved":false}
{"ts":1361207503976,"patch":[[{"diffs":[[0,"SIQ.scales;\n"],[1,"        chordType = 'scale';\n"],[0,"    } else {"]],"start1":1717,"start2":1717,"length1":24,"length2":53},{"diffs":[[0,"chords;\n"],[1,"        chordType = 'chord';\n"],[0,"    }\n  "]],"start1":1868,"start2":1868,"length1":16,"length2":45}]],"length":12056,"saved":false}
{"ts":1361207517784,"patch":[[{"diffs":[[0,"ype || \""],[-1,"C"],[1,"c"],[0,"hord\";\n}"]],"start1":1264,"start2":1264,"length1":17,"length2":17}]],"length":12056,"saved":false}
{"ts":1361208036692,"patch":[[{"diffs":[[0,"scale';\n"],[1,"        console.log(\"Checking Scale\");\n"],[0,"    } el"]],"start1":1750,"start2":1750,"length1":16,"length2":55},{"diffs":[[0,"chord';\n"],[1,"        console.log(\"Checking Chord\");\n"],[0,"    }\n  "]],"start1":1936,"start2":1936,"length1":16,"length2":55}]],"length":12134,"saved":false}
{"ts":1361208168048,"patch":[[{"diffs":[[0,"tion = '"],[-1,"M"],[1,"major"],[0,"';\n    }"]],"start1":2385,"start2":2385,"length1":17,"length2":21}]],"length":12138,"saved":false}
{"contributors":[],"silentsave":false,"ts":1361321368851,"patch":[[{"diffs":[[0,"tion = function("],[1," signature "],[0,") {\n    if( this"]],"start1":9541,"start2":9541,"length1":32,"length2":43},{"diffs":[[0,"pleNotation("],[1," signature "],[0,") + this.nam"]],"start1":9704,"start2":9704,"length1":24,"length2":35}]],"length":12160,"saved":false}
{"ts":1361321389613,"patch":[[{"diffs":[[0,"unction("],[1," signature "],[0,") {\n    "]],"start1":9887,"start2":9887,"length1":16,"length2":27},{"diffs":[[0,"pleNotation("],[1," signature "],[0,") + \" \" + th"]],"start1":10042,"start2":10042,"length1":24,"length2":35}]],"length":12182,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363903456965,"patch":[[{"diffs":[[0,"ass\n * \n"],[1," * @constructor\n"],[0," * @para"]],"start1":28,"start2":28,"length1":16,"length2":32}]],"length":12198,"saved":false}
{"ts":1363903809371,"patch":[[{"diffs":[[0,"m notes "],[-1,":"],[1,"-"],[0," a simpl"]],"start1":60,"start2":60,"length1":17,"length2":17},{"diffs":[[0,"criptor "],[-1,":"],[1,"-"],[0," an obje"]],"start1":138,"start2":138,"length1":17,"length2":17},{"diffs":[[0,"m tonic "],[-1,":"],[1,"-"],[0," the cur"]],"start1":187,"start2":187,"length1":17,"length2":17},{"diffs":[[0,"elative "],[-1,":"],[1,"-"],[0," if the "]],"start1":237,"start2":237,"length1":17,"length2":17},{"diffs":[[0,"@param type "],[-1,":"],[1,"-"],[0," the type of"]],"start1":418,"start2":418,"length1":25,"length2":25},{"diffs":[[0,"* @name "],[-1,":"],[1,"-"],[0," the cho"]],"start1":1361,"start2":1361,"length1":17,"length2":17},{"diffs":[[0,"* @type "],[-1,":"],[1,"-"],[0," the cho"]],"start1":1387,"start2":1387,"length1":17,"length2":17},{"diffs":[[0,"tes     "],[-1,":"],[1,"-"],[0," a simpl"]],"start1":3840,"start2":3840,"length1":17,"length2":17},{"diffs":[[0,"version "],[-1,":"],[1,"-"],[0," the num"]],"start1":3894,"start2":3894,"length1":17,"length2":17},{"diffs":[[0,"}\n};\n\n/*"],[-1,"*"],[0," instanc"]],"start1":9461,"start2":9461,"length1":17,"length2":16},{"diffs":[[0,"methods "],[-1,"*"],[0,"*/\n\n/**\n"]],"start1":9479,"start2":9479,"length1":17,"length2":16}]],"length":12196,"saved":false}
{"ts":1363903864420,"patch":[[{"diffs":[[0,"aj7\n * @"],[1,"param "],[0,"name - t"]],"start1":1356,"start2":1356,"length1":16,"length2":22},{"diffs":[[0,"ame\n * @"],[1,"param "],[0,"type - t"]],"start1":1388,"start2":1388,"length1":16,"length2":22}]],"length":12208,"saved":false}
{"ts":1363905443187,"patch":[[{"diffs":[[0,"ram name"],[1," {string}"],[0," - the c"]],"start1":1366,"start2":1366,"length1":16,"length2":25},{"diffs":[[0," @param type"],[1," {string}"],[0," - the chord"]],"start1":1403,"start2":1403,"length1":24,"length2":33}]],"length":12226,"saved":false}
{"ts":1363905491606,"patch":[[{"diffs":[[0,"am notes"],[1," {array}"],[0," - a sim"]],"start1":59,"start2":59,"length1":16,"length2":24},{"diffs":[[0,"scriptor"],[1," {object}"],[0," - an ob"]],"start1":145,"start2":145,"length1":16,"length2":25},{"diffs":[[0,"@param tonic"],[1," {Note}"],[0," - the curre"]],"start1":199,"start2":199,"length1":24,"length2":31},{"diffs":[[0,"relative"],[1," {boolean}"],[0," - if th"]],"start1":260,"start2":260,"length1":16,"length2":26},{"diffs":[[0,"ram type"],[1," {string}"],[0," - the t"]],"start1":455,"start2":455,"length1":16,"length2":25},{"diffs":[[0,"ype of chord"],[1,", "],[0,"\n */\n\nvar Ch"]],"start1":480,"start2":480,"length1":24,"length2":26}]],"length":12271,"saved":false}
{"ts":1363905542360,"patch":[[{"diffs":[[0,"otes    "],[1," {array}"],[0," - a sim"]],"start1":3914,"start2":3914,"length1":16,"length2":24},{"diffs":[[0,"nversion"],[1," {integer}"],[0," - the n"]],"start1":3976,"start2":3976,"length1":16,"length2":26},{"diffs":[[0," ...\n * @returns"],[1," {array} -"],[0," an array of mat"]],"start1":4110,"start2":4110,"length1":32,"length2":42},{"diffs":[[0,"g chords"],[1,", undefined when nothing is found"],[0,"\n */\nCho"]],"start1":4156,"start2":4156,"length1":16,"length2":49},{"diffs":[[0,"ertain note\n"],[1," * \n * \n"],[0," */\nChord.co"]],"start1":9390,"start2":9390,"length1":24,"length2":32}]],"length":12340,"saved":false}
{"ts":1363905666236,"patch":[[{"diffs":[[0,"note\n * \n * "],[1,"if the Chord is relative, the relative position of the Note is taken\n * \n * @param chord {Chord} - a Chord object\n * @param note {Note} - a Note object\n * @returns {boolean} - true when the Chord contains the specific note"],[0,"\n */\nChord.c"]],"start1":9397,"start2":9397,"length1":24,"length2":246},{"diffs":[[0,"proper notation\n"],[1," * \n * \n * \n * @param signature {integer} - the signature of the note\n"],[0," */\nChord.protot"]],"start1":9881,"start2":9881,"length1":32,"length2":102}]],"length":12632,"saved":false}
{"ts":1363905762545,"patch":[[{"diffs":[[0,"tion\n * \n * "],[1,"these are examples of proper notations:\n * C - an abstract C note\n * C4 - a C note on the fourth octave\n * \n * \n * if the note is abstract, we don't use"],[0,"\n * \n * @par"]],"start1":9892,"start2":9892,"length1":24,"length2":176}]],"length":12784,"saved":false}
{"ts":1363905830983,"patch":[[{"diffs":[[0,"h octave\n * "],[1,"B♭6 - A Bb note on the sixth octave"],[0,"\n * \n * if t"]],"start1":9999,"start2":9999,"length1":24,"length2":59}]],"length":12819,"saved":false}
{"ts":1363906126127,"patch":[[{"diffs":[[0,"t C "],[-1,"note"],[1,"chord"],[0,"\n * C"],[-1,"4"],[1,"#"],[0," - a C "],[-1,"note on the fourth octave\n * B♭6 - A Bb note on the sixth octave\n * \n * if the note is abstract, we don't use\n * \n * @param signature {integer} - the signature of the note"],[1,"sharp chord\n * B♭6 - A Bb7 chord\n * Cmin7 - A cminor chord\n * \n * \n * @param signature {integer} - the signature of the note\n * @returns {string} - the chord notation as it is most commonly used"],[0,"\n */"]],"start1":9961,"start2":9961,"length1":196,"length2":220},{"diffs":[[0,"otation\n"],[1," * \n * @param signature {integer} - the signature of the note\n"],[0," */\nChor"]],"start1":10504,"start2":10504,"length1":16,"length2":78},{"diffs":[[0,"ose a ch"],[-1,"a"],[1,"o"],[0,"rd with "]],"start1":10871,"start2":10871,"length1":17,"length2":17},{"diffs":[[0,"ed\n * chord\n"],[1," * \n * @param interval {Interval} - an Interval object\n * \n"],[0," */\nChord.pr"]],"start1":10934,"start2":10934,"length1":24,"length2":83}]],"length":12964,"saved":false}
{"ts":1363906158804,"patch":[[{"diffs":[[0,"\n * "],[1,"@"],[0,"returns "],[-1,"the"],[1,"{array} - An array of Note objects, all"],[0," abs"]],"start1":11294,"start2":11294,"length1":19,"length2":56},{"diffs":[[0,"absolute"],[-1," notes"],[0,"\n * \n * "]],"start1":11347,"start2":11347,"length1":22,"length2":16}]],"length":12995,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363906559277,"patch":[[{"diffs":[[0,"le name\n"],[1," * \n * @param name {string} - a possible way to describe the chord, i.e. 'maj', 'min'\n *                        'dim', etc.\n * @returns {boolean} - true if the chord can be described by this name\n"],[0," */\nChor"]],"start1":11962,"start2":11962,"length1":16,"length2":212}]],"length":13191,"saved":false}
{"ts":1363906563598,"patch":[[{"diffs":[[0," {boolean} -"],[1,"  "],[0," true if the"]],"start1":12105,"start2":12105,"length1":24,"length2":26}]],"length":13193,"saved":false}
{"ts":1363906602992,"patch":[[{"diffs":[[0,"   });\n}"],[1,";"],[0,"\n\n\n\n/**\n"]],"start1":12284,"start2":12284,"length1":16,"length2":17},{"diffs":[[0,"e notes\n"],[1," * \n * @returns {string}\n"],[0," */\nChor"]],"start1":12367,"start2":12367,"length1":16,"length2":41},{"diffs":[[0,"rns "],[-1,"an "],[1,"{"],[0,"array"],[-1," with"],[1,"} -"],[0," the"]],"start1":12607,"start2":12607,"length1":21,"length2":17},{"diffs":[[0,"ssary\n *"],[1,"                   "],[0," to form"]],"start1":12654,"start2":12654,"length1":16,"length2":35},{"diffs":[[0,"s chord\n"],[1," * \n * \n"],[0," */\nChor"]],"start1":12693,"start2":12693,"length1":16,"length2":24}]],"length":13242,"saved":false}
{"ts":1363906612153,"patch":[[{"diffs":[[0,"m this chord"],[1," (without optional notes)"],[0,"\n * \n * \n */"]],"start1":12688,"start2":12688,"length1":24,"length2":49}]],"length":13267,"saved":false}
{"ts":1363906652559,"patch":[[{"diffs":[[0," });\n}\n\n"],[1,"/**\n * @returns {string} - representing the type, can be 'chord', 'scale'\n */\n"],[0,"Chord.pr"]],"start1":12882,"start2":12882,"length1":16,"length2":94},{"diffs":[[0,"ains a note\n"],[1," * \n * @returns {boolean}\n"],[0," */\nChord.pr"]],"start1":13057,"start2":13057,"length1":24,"length2":50}]],"length":13371,"saved":false}
{"ts":1363909234405,"patch":[[{"diffs":[[0,"cal way\n"],[1," * \n * @class\n"],[0," */\nvar "]],"start1":13263,"start2":13263,"length1":16,"length2":30}]],"length":13385,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363965494909,"patch":[[{"diffs":[[0,"ram "],[-1,"notes "],[0,"{array}"],[1," notes"],[0," - a"]],"start1":58,"start2":58,"length1":21,"length2":21},{"diffs":[[0,"* @param"],[1," {object}"],[0," descrip"]],"start1":134,"start2":134,"length1":16,"length2":25},{"diffs":[[0,"scriptor"],[-1," {object}"],[0," - an ob"]],"start1":154,"start2":154,"length1":25,"length2":16},{"diffs":[[0,"ram "],[-1,"tonic "],[0,"{Note}"],[1," tonic"],[0," - t"]],"start1":202,"start2":202,"length1":20,"length2":20},{"diffs":[[0," @param "],[-1,"relative "],[0,"{boolean"]],"start1":252,"start2":252,"length1":25,"length2":16},{"diffs":[[0,"boolean}"],[1," [relative=false]"],[0," - if th"]],"start1":261,"start2":261,"length1":16,"length2":33},{"diffs":[[0,")\n * @param "],[-1,"type "],[0,"{string}"],[1," type"],[0," - the type "]],"start1":455,"start2":455,"length1":37,"length2":37}]],"length":13393,"saved":false}
{"ts":1363965504865,"patch":[[{"diffs":[[0,"string} "],[1,"["],[0,"type"],[1,"=chord]"],[0," - the t"]],"start1":468,"start2":468,"length1":20,"length2":28}]],"length":13401,"saved":false}
{"ts":1363965530777,"patch":[[{"diffs":[[0," @param "],[-1,"name "],[0,"{string}"],[1," name"],[0," - the c"]],"start1":1423,"start2":1423,"length1":29,"length2":29},{"diffs":[[0,"ram "],[-1,"type "],[0,"{string}"],[1," [type=chord]"],[0," - t"]],"start1":1468,"start2":1468,"length1":21,"length2":29}]],"length":13409,"saved":false}
{"ts":1363965577689,"patch":[[{"diffs":[[0,"rs\n * @param"],[1," {array}"],[0," notes     {"]],"start1":3924,"start2":3924,"length1":24,"length2":32},{"diffs":[[0,"otes    "],[-1," {array}"],[0," - a sim"]],"start1":3946,"start2":3946,"length1":24,"length2":16},{"diffs":[[0,"ram "],[-1,"inversion {integer}"],[1,"{integer} [inversion=0]"],[0," - t"]],"start1":3995,"start2":3995,"length1":27,"length2":31}]],"length":13413,"saved":false}
{"ts":1363965631294,"patch":[[{"diffs":[[0,"ram "],[-1,"chord "],[0,"{Chord}"],[1," chord"],[0," - a"]],"start1":9516,"start2":9516,"length1":21,"length2":21},{"diffs":[[0,"ram "],[-1,"note "],[0,"{Note}"],[1," note"],[0," - a"]],"start1":9557,"start2":9557,"length1":19,"length2":19},{"diffs":[[0," @param "],[-1,"signature {integer}"],[1,"{integer} signature"],[0," - the s"]],"start1":10080,"start2":10080,"length1":35,"length2":35},{"diffs":[[0,"ram "],[-1,"signature {integer}"],[1,"{integer} signature"],[0," - t"]],"start1":10550,"start2":10550,"length1":27,"length2":27},{"diffs":[[0," @param "],[-1,"interval "],[0,"{Interva"]],"start1":10980,"start2":10980,"length1":25,"length2":16},{"diffs":[[0,"nterval}"],[1," interval"],[0," - an In"]],"start1":10990,"start2":10990,"length1":16,"length2":25}]],"length":13413,"saved":false}
{"ts":1363965648807,"patch":[[{"diffs":[[0,"ram "],[-1,"name "],[0,"{string}"],[1," name"],[0," - a"]],"start1":12008,"start2":12008,"length1":21,"length2":21}]],"length":13413,"saved":false}
{"ts":1363965757633,"patch":[[{"diffs":[[0," * \n * @"],[-1,"returns {boolean}"],[1,"param {Note} note - a Note object\n * @returns {boolean} - true if the chord contains the note"],[0,"\n */\nCho"]],"start1":13097,"start2":13097,"length1":33,"length2":109}]],"length":13489,"saved":false}
{"ts":1363965895371,"patch":[[{"diffs":[[0," {array}"],[-1," -"],[0," an arra"]],"start1":4154,"start2":4154,"length1":18,"length2":16},{"diffs":[[0,"ns {boolean}"],[-1," -"],[0," true when t"]],"start1":9596,"start2":9596,"length1":26,"length2":24},{"diffs":[[0,"ecific note\n"],[1,""],[0," */\nChord.co"]],"start1":9644,"start2":9644,"length1":24,"length2":24},{"diffs":[[0," {array}"],[-1," -"],[0," An arra"]],"start1":11330,"start2":11330,"length1":18,"length2":16},{"diffs":[[0,"boolean}"],[-1," -"],[0,"   true "]],"start1":12129,"start2":12129,"length1":18,"length2":16},{"diffs":[[0,"{array} "],[-1,"-"],[1," "],[0," the not"]],"start1":12631,"start2":12631,"length1":17,"length2":17},{"diffs":[[0,"{string}"],[-1," -"],[0," represe"]],"start1":12926,"start2":12926,"length1":18,"length2":16},{"diffs":[[0,"- a Note object\n"],[1,""],[0," * @returns {boo"]],"start1":13113,"start2":13113,"length1":32,"length2":32},{"diffs":[[0,"boolean}"],[-1," -"],[0," true if"]],"start1":13142,"start2":13142,"length1":18,"length2":16}]],"length":13477,"saved":false}
{"contributors":[],"silentsave":false,"ts":1364049605383,"patch":[[{"diffs":[[0,"  return"],[1," null"],[0,";\n    }\n"]],"start1":2244,"start2":2244,"length1":16,"length2":21},{"diffs":[[0,"ic.pos)."],[-1,"toRelative().pos"],[1,"relPos()"],[0,";\n    })"]],"start1":3565,"start2":3565,"length1":32,"length2":24},{"diffs":[[0,"aram {array}"],[1,"  "],[0," notes     -"]],"start1":3929,"start2":3929,"length1":24,"length2":26},{"diffs":[[0,"tes     "],[1,"    "],[0,"- a simp"]],"start1":3946,"start2":3946,"length1":16,"length2":20},{"diffs":[[0,"        "],[1,"              "],[0,"0 = root"]],"start1":4072,"start2":4072,"length1":16,"length2":30},{"diffs":[[0,"ersion, "],[1,"\n *                                  "],[0,"2 = seco"]],"start1":4126,"start2":4126,"length1":16,"length2":53},{"diffs":[[0,"on, ...\n"],[1," * \n"],[0," * @retu"]],"start1":4189,"start2":4189,"length1":16,"length2":20},{"diffs":[[0,"e. '"],[1,"C"],[0,"maj', '"],[1,"D#"],[0,"min'"]],"start1":12120,"start2":12120,"length1":15,"length2":18},{"diffs":[[0,"', etc.\n"],[1," *                      - should support both # and b, ♭ and ♯\n"],[0," * @retu"]],"start1":12169,"start2":12169,"length1":16,"length2":79},{"diffs":[[0,"is name\n */\n"],[-1,""],[0,"Chord.protot"]],"start1":12304,"start2":12304,"length1":24,"length2":24},{"diffs":[[0,"tion(name){\n"],[1,"    \n    // split it between the note and the chord type indicator\n    \n    \n"],[0,"    return _"]],"start1":12346,"start2":12346,"length1":24,"length2":101}]],"length":13678,"saved":false}
{"ts":1364049918714,"patch":[[{"diffs":[[1,"\"use strict\";\n"],[0,"/**\n * the MUSIQ"]],"start1":0,"start2":0,"length1":16,"length2":30},{"diffs":[[0,"dicator\n    "],[1,"var matches = MUSIQ.isValidChord( name );\n    \n    // if the name is not even valid, return false\n    if(!matches ) return false;\n    \n    // check if the tonic is the same\n    if( !this.tonic.hasName( matches[1] + (matches[2] || \"\") )) return false;\n    \n    //console.log( tonic );\n    var notation = matches[3];"],[0,"\n    \n    re"]],"start1":12431,"start2":12431,"length1":24,"length2":338}]],"length":14006,"saved":false}
{"ts":1364049942567,"patch":[[{"diffs":[[0,"es[3];\n    \n"],[1,"    // and finally check the notation\n"],[0,"    return _"]],"start1":12751,"start2":12751,"length1":24,"length2":62},{"diffs":[[0,"    return n"],[-1,"ame"],[1,"otation"],[0," == n;\n    }"]],"start1":12848,"start2":12848,"length1":27,"length2":31}]],"length":14048,"saved":false}
{"ts":1364050103964,"patch":[[{"diffs":[[0,"ookup;\n    \n"],[1,"    var chordType = \"\";\n    \n"],[0,"    if( type"]],"start1":1743,"start2":1743,"length1":24,"length2":53}]],"length":14077,"saved":false}
{"contributors":[],"silentsave":false,"ts":1364082346096,"patch":[[{"diffs":[[0,"cale'\n * \n *"],[-1,""],[0,""],[1," @returns {Chord}\n *"],[0,"/\nChord.from"]],"start1":1546,"start2":1546,"length1":24,"length2":44},{"diffs":[[0,"scale';\n        "],[-1,""],[0,""],[1,"//"],[0,"console.log(\"Che"]],"start1":1928,"start2":1928,"length1":32,"length2":34},{"diffs":[[0,"chord';\n        "],[-1,""],[0,""],[1,"//"],[0,"console.log(\"Che"]],"start1":2116,"start2":2116,"length1":32,"length2":34},{"diffs":[[0,"ns {"],[-1,"array} an array of"],[1,"Chord} a"],[0," mat"]],"start1":4277,"start2":4277,"length1":26,"length2":16},{"diffs":[[0,"hord"],[-1,"s"],[0,", "],[-1,"undefined"],[1,"null"],[0," whe"]],"start1":4300,"start2":4300,"length1":20,"length2":14},{"diffs":[[0,"var "],[-1,"ret = [];\n    \n    // make a nice array of Note objects from the notes parameter\n    var noteObjects = _.map( notes, function(note) {\n        return new Note(note);\n    });\n    \n    //console.log( \"fromNotes with inversion \" + inversion );\n    \n    if (_.isNumber(inversion) && inversion > -1) {\n        // specified an inversion, we first determine the tonic\n\n        // sort the notes from lowest to highest\n        var relNotes = notes.slice();\n\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //_.each(relNotes, function(item){console.log((new Note(item).notation()))});\n        \n        // determine the tonic - the lowest note\n        var tonic = relNotes[inversion];\n\n        //var uniqueNotes = _.uniq(relNotes);\n\n        // make the notes relative to the tonic\n        relNotes = _.map(relNotes, function(note) {\n            return note - tonic;\n        });\n        \n        //console.log(relNotes);\n        \n        // wrap negative notes\n        relNotes = _.map( relNotes, function(note){\n            if( note < 0 ){\n                // move it enough octaves up\n                var n = note - (Math.floor( note / 12 ) * 12);\n                console.assert( n >= 0);\n                return n;\n            } else {\n                return note;\n            }\n        });\n        \n        //console.log(relNotes);\n        \n        // now find the chords for all the different possible inversions\n\n        //console.log(relNotes);\n\n\n        // get the notes within two octaves of the tonic\n        var relNotes = _.map(relNotes, function(note) {\n            if( note < 0 ) {\n                console.log(\"ERROR: negative note! \");\n            }\n            else if (note < 12) {\n                return note;\n            }\n            else {\n                // filter out special notes, like 9th, 11th and 13th\n                var relNote = note % 12;\n                if (MUSIQ.chordExtensionNotes.indexOf(relNote) > -1) {\n                    return relNote + 12;\n                }\n                else {\n                    return relNote;\n                }\n            }\n\n        });\n\n        //console.log(relNotes);\n\n        //console.log( relNotes );\n        // now remove duplicates\n        relNotes = _.uniq(relNotes);\n        \n        // sort the notes\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //console.log(inversion + \" : \" + \" [ \" + relNotes + \" ]\");\n\n        //console.log(\"Check descriptors\");\n        \n        // find chords in the descriptor list that match\n        var matchedChordDescrs = _(MUSIQ.chords).filter(function(chord) {\n            \n            \n            if( chord.optional ){\n                // remove all optional notes from the source array\n                \n                // so we're only left with the absolute required notes to form this chord\n                var notesReq = _(relNotes).difference(chord.optional);\n                var chordNotesReq = _(chord.notes).difference(chord.optional);\n                \n                //console.log( notesReq + \" - \" + chord.notes );\n                \n                return _(chordNotesReq).isEqual(relNotes ) || _(chordNotesReq).isEqual(notesReq);\n            } else {\n                return _(chord.notes).isEqual(relNotes);\n            }\n        }, this);\n        \n        // filter duplicates\n        matchedChordDescrs = _.uniq(matchedChordDescrs);\n\n        var matchedChords = _.map( matchedChordDescrs, function(item){\n            // add the matched chords to the return array\n            return new Chord(noteObjects, item, new Note(tonic));\n        } );\n        \n        // only log this if we found a matched chord\n        if( matchedChords.length > 0){\n           // var tonicNote = new Note(tonic);\n            \n            //console.log(tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n            //console.log( \"found in inversion \" + inversion  + \"(\" + tonicNote.simpleNotation() + \") - [ \" + relNotes + \"]\");\n            //console.log(notes);\n            //console.log(relNotes);\n        }\n        \n        //console.log( matchedChords );\n        \n        return matchedChords;\n\n    }\n    // no inversion specified\n    else {\n        // simple list of chord tonics to check if we have looked for\n        // specific chords already\n        var chordTonics = [];\n        for (var i = 0; i < notes.length; i++) {\n            // add matched chords from all inversions of this chord\n            var curNote = new Note(notes[i]);\n            \n            if( chordTonics.indexOf(curNote.toRelative().pos) > -1){\n                continue;\n            }\n            \n            chordTonics.push(curNote.toRelative().pos);\n            \n            var matchedChords = Chord.fromNotes(notes, i);\n            \n            \n            ret = ret.concat(matchedChords);\n        }\n        \n        //console.log( chordTonics);\n        \n        // remove any duplicates\n        \n        \n        //console.log( ret );\n        \n        if( !(ret.length > 0) ){\n            //console.log(\"Chord not found!\");\n        }\n        return ret;\n    }\n    "],[1,"matches = Chords.fromNotes( notes, inversion );\n    if( matches && matches.length > 0 ){\n        return matches[0];\n    }\n    return null;"],[0,"\n};\n"]],"start1":4394,"start2":4394,"length1":5091,"length2":146},{"diffs":[[0,"                "],[-1,""],[0,""],[1,"//"],[0,"console.log(this"]],"start1":6846,"start2":6846,"length1":32,"length2":34},{"diffs":[[0,"this );\n    "],[1,"//"],[0,"console.log("]],"start1":7000,"start2":7000,"length1":24,"length2":26},{"diffs":[[0,"ects\");\n    "],[1,"//"],[0,"console.log("]],"start1":7034,"start2":7034,"length1":24,"length2":26},{"diffs":[[0,"ame );\n    \n"],[1,"    //console.log( matches );\n"],[0,"    // if th"]],"start1":7576,"start2":7576,"length1":24,"length2":54},{"diffs":[[0,"    "],[-1,"var notation = matches[3]"],[1,"\n    // if the notation is undefined (from the match), it couldn't be found (no text),\n    // but it can still result in a valid chord\n    var notation = matches[3] || \"\";\n    \n    if( notation === \"\") \n        console.warn( notation )"],[0,";\n  "]],"start1":7855,"start2":7855,"length1":33,"length2":243},{"diffs":[[0,"otation\n    "],[-1,"return"],[1,"\n    var found ="],[0," _(this.name"]],"start1":8131,"start2":8131,"length1":30,"length2":40},{"diffs":[[0,"ation =="],[1,"="],[0," n;\n    "]],"start1":8210,"start2":8210,"length1":16,"length2":17},{"diffs":[[0,"    });\n"],[1,"    \n    console.log( found );\n    return found;\n"],[0,"};\n\n\n\n/*"]],"start1":8223,"start2":8223,"length1":16,"length2":65},{"diffs":[[0,"s = {};\n"],[1,"\n\n"],[0,"Chords.f"]],"start1":9359,"start2":9359,"length1":16,"length2":18},{"diffs":[[0,"s = "],[-1,"Chord.fromNotes;"],[1,"function( notes, inversion ){\n    \n    var ret = [];\n    \n    // make a nice array of Note objects from the notes parameter\n    var noteObjects = _.map( notes, function(note) {\n        return new Note(note);\n    });\n    \n    //console.log( \"fromNotes with inversion \" + inversion );\n    \n    if (_.isNumber(inversion) && inversion > -1) {\n        // specified an inversion, we first determine the tonic\n\n        // sort the notes from lowest to highest\n        var relNotes = notes.slice();\n\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //_.each(relNotes, function(item){console.log((new Note(item).notation()))});\n        \n        // determine the tonic - the lowest note\n        var tonic = relNotes[inversion];\n\n        //var uniqueNotes = _.uniq(relNotes);\n\n        // make the notes relative to the tonic\n        relNotes = _.map(relNotes, function(note) {\n            return note - tonic;\n        });\n        \n        //console.log(relNotes);\n        \n        // wrap negative notes\n        relNotes = _.map( relNotes, function(note){\n            if( note < 0 ){\n                // move it enough octaves up\n                var n = note - (Math.floor( note / 12 ) * 12);\n                console.assert( n >= 0);\n                return n;\n            } else {\n                return note;\n            }\n        });\n        \n        //console.log(relNotes);\n        \n        // now find the chords for all the different possible inversions\n\n        //console.log(relNotes);\n\n\n        // get the notes within two octaves of the tonic\n        var relNotes = _.map(relNotes, function(note) {\n            if( note < 0 ) {\n                console.log(\"ERROR: negative note! \");\n            }\n            else if (note < 12) {\n                return note;\n            }\n            else {\n                // filter out special notes, like 9th, 11th and 13th\n                var relNote = note % 12;\n                if (MUSIQ.chordExtensionNotes.indexOf(relNote) > -1) {\n                    return relNote + 12;\n                }\n                else {\n                    return relNote;\n                }\n            }\n\n        });\n\n        //console.log(relNotes);\n\n        //console.log( relNotes );\n        // now remove duplicates\n        relNotes = _.uniq(relNotes);\n        \n        // sort the notes\n        relNotes.sort(function(a, b) { return a - b; });\n\n        //console.log(inversion + \" : \" + \" [ \" + relNotes + \" ]\");\n\n        //console.log(\"Check descriptors\");\n        \n        // find chords in the descriptor list that match\n        var matchedChordDescrs = _(MUSIQ.chords).filter(function(chord) {\n            \n            \n            if( chord.optional ){\n                // remove all optional notes from the source array\n                \n                // so we're only left with the absolute required notes to form this chord\n                var notesReq = _(relNotes).difference(chord.optional);\n                var chordNotesReq = _(chord.notes).difference(chord.optional);\n                \n                //console.log( notesReq + \" - \" + chord.notes );\n                \n                return _(chordNotesReq).isEqual(relNotes ) || _(chordNotesReq).isEqual(notesReq);\n            } else {\n                return _(chord.notes).isEqual(relNotes);\n            }\n        }, this);\n        \n        // filter duplicates\n        matchedChordDescrs = _.uniq(matchedChordDescrs);\n\n        var matchedChords = _.map( matchedChordDescrs, function(item){\n            // add the matched chords to the return array\n            return new Chord(noteObjects, item, new Note(tonic));\n        } );\n        \n        // only log this if we found a matched chord\n        if( matchedChords.length > 0){\n           // var tonicNote = new Note(tonic);\n            \n            //console.log(tonicNote.simpleNotation() + \" [ \" + relNotes + \" ]\");\n            //console.log( \"found in inversion \" + inversion  + \"(\" + tonicNote.simpleNotation() + \") - [ \" + relNotes + \"]\");\n            //console.log(notes);\n            //console.log(relNotes);\n        }\n        \n        //console.log( matchedChords );\n        \n        return matchedChords;\n\n    }\n    // no inversion specified\n    else {\n        // simple list of chord tonics to check if we have looked for\n        // specific chords already\n        var chordTonics = [];\n        for (var i = 0; i < notes.length; i++) {\n            // add matched chords from all inversions of this chord\n            var curNote = new Note(notes[i]);\n            \n            if( chordTonics.indexOf(curNote.toRelative().pos) > -1){\n                continue;\n            }\n            \n            chordTonics.push(curNote.toRelative().pos);\n            \n            var matchedChords = Chords.fromNotes(notes, i);\n            \n            \n            ret = ret.concat(matchedChords);\n        }\n        \n        //console.log( chordTonics);\n        \n        //console.log( ret );\n        \n        if( !(ret.length > 0) ){\n            //console.log(\"Chord not found!\");\n        }\n        return ret;\n    }\n    \n};\n"],[0,"\nCho"]],"start1":9384,"start2":9384,"length1":24,"length2":5088}]],"length":14512,"saved":false}
{"ts":1364082580502,"patch":[[{"diffs":[[0,"rn found"],[1," ? true : false"],[0,";\n};\n\n\n\n"]],"start1":8270,"start2":8270,"length1":16,"length2":31}]],"length":14527,"saved":false}
{"ts":1364082785252,"patch":[[{"diffs":[[0,"    "],[-1,"return found"],[1,"\n    // NOTE: the _.find() function returns undefined when the item hasn't been found\n    return typeof(found) == 'undefined'"],[0," ? t"]],"start1":8262,"start2":8262,"length1":20,"length2":133}]],"length":14640,"saved":false}
{"ts":1364082806265,"patch":[[{"diffs":[[0,"' ? "],[-1,"true : fals"],[1,"false : tru"],[0,"e;\n}"]],"start1":8390,"start2":8390,"length1":19,"length2":19}]],"length":14640,"saved":false}
{"contributors":[],"silentsave":false,"ts":1364084400535,"patch":[[{"diffs":[[0,"ation;\n\n"],[1,"/**\n * shortcut function to create a new chord based on Chord.fromNotation()\n * \n */\nfunction Chord( name, type ){\n    return Chord.fromNotation(name, type);\n}"]],"start1":14632,"start2":14632,"length1":8,"length2":167}]],"length":14799,"saved":false}
