{"ts":1363901682221,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*global app: true, args: true, env: true, publish: true */\n/**\n * @project jsdoc\n * @author Michael Mathews <micmath@gmail.com>\n * @license See LICENSE.md file included in this distribution.\n */\n\n// try: $ java -classpath build-files/java/classes/js.jar org.mozilla.javascript.tools.shell.Main main.js `pwd` script/to/parse.js\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n/**\n * Data representing the environment in which this app is running.\n *\n * @namespace\n * @name env\n */\nrequire('lib/jsdoc/util/global').env = {\n    /**\n     * Running start and finish times.\n     * \n     * @memberof env\n     */\n    run: {\n        start: new Date(),\n        finish: null\n    },\n\n    /**\n     * The command-line arguments passed into JSDoc.\n     *\n     * @type Array\n     * @memberof env\n     */\n    args: [],\n\n    /**\n     * The parsed JSON data from the configuration file.\n     * \n     * @type Object\n     * @memberof env\n     */\n    conf: {},\n\n    /**\n     * The absolute path to the base directory of the JSDoc application.\n     * \n     * @private\n     * @deprecated Use `__dirname` instead.\n     * @type string\n     * @memberof env\n     */\n    dirname: '.',\n\n    /**\n     * The command-line arguments, parsed into a key/value hash.\n     * \n     * @type Object\n     * @memberof env\n     * @example if (env.opts.help) { console.log('Helpful message.'); }\n    */\n    opts: {},\n\n    /**\n     * The JSDoc version number and revision date.\n     * \n     * @type Object\n     * @memberof env\n     */\n    version: {}\n};\n\n// initialize the environment for the current JavaScript VM\n(function(args) {\n    var vm = require('jsdoc/util/vm').vm;\n    // TODO: may need to move this file to support Node.js\n    require('initialize')[vm](args);\n})( Array.prototype.slice.call(arguments, 0) );\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n/**\n * Data that must be shared across the entire application.\n * @namespace\n * @name app\n */\nrequire('lib/jsdoc/util/global').app = {\n    jsdoc: {\n        scanner: new (require('jsdoc/src/scanner').Scanner)(),\n        parser: new (require('jsdoc/src/parser').Parser)(),\n        name: require('jsdoc/name')\n    }\n};\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n/**\n    Try to recursively print out all key/values in an object.\n    @global\n    @private\n    @param {Object} ... Object/s to dump out to console.\n */\nfunction dump() {\n    var doop = require('jsdoc/util/doop').doop;\n    var _dump = require('jsdoc/util/dumper').dump;\n    for (var i = 0, l = arguments.length; i < l; i++) {\n        console.log( _dump(doop(arguments[i])) );\n    }\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n/**\n * Run the jsdoc application.\n * @todo Refactor function (and require statements) into smaller functions\n */\nfunction main() {\n    var _ = require('underscore');\n    var args = require('jsdoc/opts/args');\n    var augment = require('jsdoc/augment');\n    var borrow = require('jsdoc/borrow');\n    var Config = require('jsdoc/config');\n    var Filter = require('jsdoc/src/filter').Filter;\n    var fs = require('jsdoc/fs');\n    var handlers = require('jsdoc/src/handlers');\n    var include = require('jsdoc/util/include');\n    var Package = require('jsdoc/package').Package;\n    var path = require('jsdoc/path');\n    var plugins = require('jsdoc/plugins');\n    var Readme = require('jsdoc/readme');\n    var resolver = require('jsdoc/tutorial/resolver');\n    var taffy = require('taffydb').taffy;\n    var vm = require('jsdoc/util/vm');\n\n    var defaultOpts;\n    var docs;\n    var exampleConf;\n    var filter;\n    var i;\n    var info;\n    var l;\n    var packageDocs;\n    var packageJson;\n    var sourceFiles;\n    var template;\n\n\n    defaultOpts = {\n        destination: './out/',\n        encoding: 'utf8'\n    };\n\n    // get JSDoc version number\n    info = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf8'));\n    env.version = {\n        number: info.version,\n        revision: new Date(parseInt(info.revision, 10)).toUTCString()\n    };\n\n    env.opts = args.parse(env.args);\n\n    try {\n        env.conf = new Config(\n            fs.readFileSync( env.opts.configure || path.join(__dirname, 'conf.json'), 'utf8' )\n        ).get();\n    }\n    catch (e) {\n        try {\n            // Use the example file if possible\n            exampleConf = fs.readFileSync(path.join(__dirname, 'conf.json.EXAMPLE'), 'utf8');\n            env.conf = JSON.parse(exampleConf);\n        }\n        catch(e) {\n            throw('Configuration file cannot be evaluated. ' + e);\n        }\n    }\n\n    // look for options on the command line, in the config file, and in the defaults, in that order\n    env.opts = _.defaults(env.opts, env.conf.opts, defaultOpts);\n\n    // which version of javascript will be supported? (rhino only)\n    if (typeof version === 'function') {\n        version(env.conf.jsVersion || 180);\n    }\n\n    if (env.opts.help) {\n        console.log( args.help() );\n        process.exit(0);\n    } else if (env.opts.test) {\n        include('test/runner.js');\n        process.exit(0);\n    } else if (env.opts.version) {\n        console.log('JSDoc ' + env.version.number + ' (' + env.version.revision + ')');\n        process.exit(0);\n    }\n\n    if (env.conf.plugins) {\n        plugins.installPlugins(env.conf.plugins, app.jsdoc.parser);\n    }\n    \n    if (env.conf.source && env.conf.source.include) {\n        env.opts._ = (env.opts._ || []).concat(env.conf.source.include);\n    }\n\n    // any source file named package.json or README.md is treated special\n    for (i = 0, l = env.opts._.length; i < l; i++ ) {\n        if (/\\bpackage\\.json$/i.test(env.opts._[i])) {\n            packageJson = fs.readFileSync( env.opts._[i], 'utf8' );\n            env.opts._.splice(i--, 1);\n        }\n        \n        if (/(\\bREADME|\\.md)$/i.test(env.opts._[i])) {\n            env.opts.readme = new Readme(env.opts._[i]).html;\n            env.opts._.splice(i--, 1);\n        }\n    }\n    \n    if (env.conf.source && env.opts._.length > 0) { // are there any files to scan and parse?\n        filter = new Filter(env.conf.source);\n\n        sourceFiles = app.jsdoc.scanner.scan(env.opts._, (env.opts.recurse? 10 : undefined), filter);\n\n        handlers.attachTo(app.jsdoc.parser);\n\n        docs = app.jsdoc.parser.parse(sourceFiles, env.opts.encoding);\n\n        //The files are ALWAYS useful for the templates to have\n        //If there is no package.json, just create an empty package\n        packageDocs = new Package(packageJson);\n        packageDocs.files = sourceFiles || [];\n        docs.push(packageDocs);\n\n        borrow.indexAll(docs);\n\n        augment.addInherited(docs);\n        borrow.resolveBorrows(docs);\n\n        if (env.opts.explain) {\n            console.log(docs);\n            process.exit(0);\n        }\n\n        if (env.opts.tutorials) {\n            resolver.load(env.opts.tutorials);\n            resolver.resolve();\n        }\n\n        env.opts.template = (function() {\n            var publish = env.opts.template || 'templates/default';\n            // if we don't find it, keep the user-specified value so the error message is useful\n            return path.getResourcePath(publish) || env.opts.template;\n        })();\n\n        try {\n            template = require(env.opts.template + '/publish');\n        }\n        catch(e) {\n            throw new Error('Unable to load template: ' + e.message || e);\n        }\n\n        // templates should include a publish.js file that exports a \"publish\" function\n        if (template.publish && typeof template.publish === 'function') {\n            // convert this from a URI back to a path if necessary\n            env.opts.template = path._uriToPath(env.opts.template);\n            template.publish(\n                taffy(docs),\n                env.opts,\n                resolver.root\n            );\n        }\n        else {\n            // old templates define a global \"publish\" function, which is deprecated\n            include(env.opts.template + '/publish.js');\n            if (publish && typeof publish === 'function') {\n                console.log( env.opts.template + ' uses a global \"publish\" function, which is ' +\n                    'deprecated and may not be supported in future versions. ' +\n                    'Please update the template to use \"exports.publish\" instead.' );\n                // convert this from a URI back to a path if necessary\n                env.opts.template = path._uriToPath(env.opts.template);\n                publish(\n                    taffy(docs),\n                    env.opts,\n                    resolver.root\n                );\n            }\n            else {\n                throw new Error( env.opts.template + ' does not export a \"publish\" function.' );\n            }\n        }\n    }\n}\n\ntry {\n    main();\n    env.run.finish = new Date();\n    process.exit(0);\n}\ncatch(e) {\n    env.run.finish = new Date();\n    if (e.rhinoException != null) {\n        e.rhinoException.printStackTrace();\n        process.exit(1);\n    } else {\n        throw e;\n    }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":9096}]],"length":9096}
