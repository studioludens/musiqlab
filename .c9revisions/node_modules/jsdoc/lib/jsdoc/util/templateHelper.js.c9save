{"ts":1363975879095,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*global env: true */\n/**\n * @module jsdoc/util/templateHelper\n */\n\nvar dictionary = require('jsdoc/tag/dictionary');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar files = {};\n\n// each container gets its own html file\nvar containers = ['class', 'module', 'external', 'namespace', 'mixin'];\n\nvar tutorials;\n\n/** Sets tutorials map.\n    @param {jsdoc.tutorial.Tutorial} root - Root tutorial node.\n */\nexports.setTutorials = function(root) {\n    tutorials = root;\n};\n\nexports.globalName = 'global';\nexports.fileExtension = '.html';\nexports.scopeToPunc = { 'static': '.', 'inner': '~', 'instance': '#' };\n\nfunction getNamespace(kind) {\n    if (dictionary.isNamespace(kind)) {\n        return kind + ':';\n    }\n    return '';\n}\n\nfunction makeFilenameUnique(filename, str) {\n    var key = filename.toLowerCase();\n    var nonUnique = true;\n\n    // append enough underscores to make the filename unique\n    while (nonUnique) {\n        if ( files[key] && hasOwnProp.call(files, key) ) {\n            filename += '_';\n            key = filename.toLowerCase();\n        } else {\n            nonUnique = false;\n        }\n    }\n\n    files[key] = str;\n    return filename;\n}\n\n// compute it here just once\nvar nsprefix = /^(event|module|external):/;\n\n/**\n * Convert a string to a unique filename, including an extension.\n *\n * Filenames are cached to ensure that they are used only once. For example, if the same string is\n * passed in twice, two different filenames will be returned.\n *\n * Also, filenames are not considered unique if they are capitalized differently but are otherwise\n * identical.\n * @param {string} str The string to convert.\n * @return {string} The filename to use for the string.\n */\nvar getUniqueFilename = exports.getUniqueFilename = function(str) {\n    // allow for namespace prefix\n    var basename = str.replace(nsprefix, '$1-')\n        // and use - instead of ~ to denote 'inner'\n        .replace(/~/g, '-');\n    \n    // if the basename includes characters that we can't use in a filepath, remove everything up to\n    // and including the last bad character\n    var regexp = /[^$a-z0-9._\\-](?=[$a-z0-9._\\-]*$)/i;\n    var result = regexp.exec(basename);\n    if (result && result.index) {\n        basename = basename.substr(result.index + 1);\n    }\n\n    // make sure we don't create hidden files on POSIX systems\n    basename = basename.replace(/^\\./, '');\n    // and in case we've now stripped the entire basename (uncommon, but possible):\n    basename = basename.length ? basename : '_';\n\n    return makeFilenameUnique(basename, str) + exports.fileExtension;\n};\n\n// two-way lookup\nvar linkMap = {\n    longnameToUrl: {},\n    urlToLongname: {}\n};\n\nvar tutorialLinkMap = {\n    nameToUrl: {},\n    urlToName: {}\n};\n\nvar longnameToUrl = exports.longnameToUrl = linkMap.longnameToUrl;\n\nfunction parseType(longname) {\n    var catharsis = require('catharsis');\n    var err;\n\n    try {\n        return catharsis.parse(longname, {jsdoc: true});\n    }\n    catch (e) {\n        err = new Error('unable to parse ' + longname + ': ' + e.message);\n        require('jsdoc/util/error').handle(err);\n        return longname;\n    }\n}\n\n/**\n * Retrieve an HTML link to the member with the specified longname. If the longname is not\n * associated with a URL, this method returns the link text, if provided, or the longname.\n *\n * This method supports type applications that can contain one or more types, such as\n * `Array.<MyClass>` or `Array.<(MyClass|YourClass)>`. In these examples, the method attempts to\n * replace `Array`, `MyClass`, and `YourClass` with links to the appropriate types. The link text\n * is ignored for type applications.\n *\n * @param {string} longname - The longname that is the target of the link.\n * @param {string=} linktext - The text to display for the link, or `longname` if no text is\n * provided.\n * @param {string=} cssClass - The CSS class (or classes) to include in the link's `<a>` tag.\n * @return {string} The HTML link, or a plain-text string if the link is not available.\n */\nvar linkto = exports.linkto = function(longname, linktext, cssClass) {\n    var catharsis = require('catharsis');\n\n    var classString = cssClass ? util.format(' class=\"%s\"', cssClass) : '';\n    var text = linktext || longname;\n    var url = hasOwnProp.call(longnameToUrl, longname) && longnameToUrl[longname];\n    var parsedType;\n\n    // handle complex type expressions that may require multiple links\n    if (longname && longname.search(/[<{(]/) !== -1) {\n        parsedType = parseType(longname);\n        return catharsis.stringify(parsedType, {\n            cssClass: cssClass,\n            htmlSafe: true,\n            links: longnameToUrl\n        });\n    }\n\n    if (!url) {\n        return text;\n    }\n    else {\n        return util.format('<a href=\"%s\"%s>%s</a>', url, classString, text);\n    }\n};\n\nvar htmlsafe = exports.htmlsafe = function(str) {\n    return str.replace(/</g, '&lt;');\n};\n\n/**\n * Find items in a TaffyDB database that match the specified key-value pairs.\n * @param {TAFFY} data The TaffyDB database to search.\n * @param {object|function} spec Key-value pairs to match against (for example,\n * `{ longname: 'foo' }`), or a function that returns `true` if a value matches or `false` if it\n * does not match.\n * @return {array<object>} The matching items.\n */\nvar find = exports.find = function(data, spec) {\n    return data(spec).get();\n};\n\n/**\n * Retrieve all of the following types of members from a set of doclets:\n *\n * + Classes\n * + Externals\n * + Globals\n * + Mixins\n * + Modules\n * + Namespaces\n * + Events\n * @param {TAFFY} data The TaffyDB database to search.\n * @return {object} An object with `classes`, `externals`, `globals`, `mixins`, `modules`,\n * `events`, and `namespaces` properties. Each property contains an array of objects.\n */\nexports.getMembers = function(data) {\n    return {\n        classes: find( data, {kind: 'class'} ),\n        externals: find( data, {kind: 'external'} ),\n        events: find( data, {kind: 'event'} ),\n        globals: find(data, {\n            kind: ['member', 'function', 'constant', 'typedef'],\n            memberof: { isUndefined: true }\n        }),\n        mixins: find( data, {kind: 'mixin'} ),\n        modules: find( data, {kind: 'module'} ),\n        namespaces: find( data, {kind: 'namespace'} )\n    };\n};\n\n/**\n * Retrieve the member attributes for a doclet (for example, `virtual`, `static`, and\n * `readonly`).\n * @param {object} d The doclet whose attributes will be retrieved.\n * @return {array<string>} The member attributes for the doclet.\n */\nexports.getAttribs = function(d) {\n    var attribs = [];\n    \n    if (d.virtual) {\n        attribs.push('virtual');\n    }\n    \n    if (d.access && d.access !== 'public') {\n        attribs.push(d.access);\n    }\n    \n    if (d.scope && d.scope !== 'instance' && d.scope !== 'global') {\n        if (d.kind == 'function' || d.kind == 'member' || d.kind == 'constant') {\n            attribs.push(d.scope);\n        }\n    }\n    \n    if (d.readonly === true) {\n        if (d.kind == 'member') {\n            attribs.push('readonly');\n        }\n    }\n    \n    if (d.kind === 'constant') {\n        attribs.push('constant');\n    }\n\n    return attribs;\n};\n\n/**\n * Retrieve links to allowed types for the member.\n *\n * @param {Object} d - The doclet whose types will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to allowed types for the member.\n */\nexports.getSignatureTypes = function(d, cssClass) {\n    var types = [];\n    \n    if (d.type && d.type.names) {\n        types = d.type.names;\n    }\n    \n    if (types && types.length) {\n        types = types.map(function(t) {\n            return linkto(t, htmlsafe(t), cssClass);\n        });\n    }\n\n    return types;\n};\n\n/**\n * Retrieve names of the parameters that the member accepts. If a value is provided for `optClass`,\n * the names of optional parameters will be wrapped in a `<span>` tag with that class.\n * @param {object} d The doclet whose parameter names will be retrieved.\n * @param {string} [optClass] The class to assign to the `<span>` tag that is wrapped around the\n * names of optional parameters. If a value is not provided, optional parameter names will not be\n * wrapped with a `<span>` tag. Must be a legal value for a CSS class name.\n * @return {array<string>} An array of parameter names, with or without `<span>` tags wrapping the\n * names of optional parameters.\n */\nexports.getSignatureParams = function(d, optClass) {\n    var pnames = [];\n\n    if (d.params) {\n        d.params.forEach(function(p) {\n            if (p.name && p.name.indexOf('.') === -1) {\n                if (p.optional && optClass) {\n                    pnames.push('<span class=\"' + optClass + '\">' + p.name + '</span>');\n                }\n                else {\n                    pnames.push(p.name);\n                }\n            }\n        });\n    }\n\n    return pnames;\n};\n\n/**\n * Retrieve links to types that the member can return.\n *\n * @param {Object} d - The doclet whose types will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to types that the member can return.\n */\nexports.getSignatureReturns = function(d, cssClass) {\n    var returnTypes = [];\n    \n    if (d.returns) {\n        d.returns.forEach(function(r) {\n            if (r.type && r.type.names) {\n                if (!returnTypes.length) {\n                    returnTypes = r.type.names;\n                }\n            }\n        });\n    }\n    \n    if (returnTypes && returnTypes.length) {\n        returnTypes = returnTypes.map(function(r) {\n            return linkto(r, htmlsafe(r), cssClass);\n        });\n    }\n\n    return returnTypes;\n};\n\n/**\n * Retrieve links to a member's ancestors.\n *\n * @param {TAFFY} data - The TaffyDB database to search.\n * @param {Object} doclet - The doclet whose ancestors will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to a member's ancestors.\n */\nexports.getAncestorLinks = function(data, doclet, cssClass) {\n    var ancestors = [],\n        doc = doclet.memberof;\n\n    while (doc) {\n        doc = find( data, {longname: doc}, false );\n        if (doc) { doc = doc[0]; }\n        if (!doc) { break; }\n        ancestors.unshift( linkto(doc.longname, (exports.scopeToPunc[doc.scope] || '') + doc.name,\n            cssClass) );\n        doc = doc.memberof;\n    }\n    if (ancestors.length) {\n        ancestors[ancestors.length - 1] += (exports.scopeToPunc[doclet.scope] || '');\n    }\n    return ancestors;\n};\n\n/**\n * Remove members that will not be included in the output, including:\n *\n * + Undocumented members.\n * + Members tagged `@ignore`.\n * + Members of anonymous classes.\n * + Members tagged `@private`, unless the `private` option is enabled.\n * @param {TAFFY} data The TaffyDB database to prune.\n * @return {TAFFY} The pruned database.\n */\nexports.prune = function(data) {\n    data({undocumented: true}).remove();\n    data({ignore: true}).remove();\n    if (!env.opts.private) { data({access: 'private'}).remove(); }\n    data({memberof: '<anonymous>'}).remove();\n\n    return data;\n};\n\nvar registerLink = exports.registerLink = function(longname, url) {\n    linkMap.longnameToUrl[longname] = url;\n    linkMap.urlToLongname[url] = longname;\n};\n\nfunction toLink(longname, content, monospace) {\n    if (!longname) {\n        // if this happens, there's something wrong with the caller itself; the user can't fix this\n        throw new Error('Missing required parameter: url');\n    }\n    var monospaceLinks = env.conf.templates.monospaceLinks;\n    var cleverLinks = env.conf.templates.cleverLinks;\n  \n    // Split into URL and content.\n    // Has link text been specified {@link link|content}, e.g.\n    // {@link http://github.com|Github} or {@link MyNamespace.method|Method}\n    // Note: only do if `content` has not been supplied, i.e. in the case of\n    // [content]{@link ...} we use `content`.\n    //\n    // If pipe is not present we use the first space.\n    var split = longname.indexOf('|');\n    if (split === -1) {\n       split = longname.indexOf(' ');\n    }\n    if (split !== -1 && !content) {\n        content = longname.substr(split + 1);\n        longname = longname.substr(0, split);\n    }\n\n    var url;\n    var isURL = false;\n    // Has link been specified manually?\n    if (/^(http|ftp)s?:/.test(longname)) {\n        isURL = true;\n        url = longname;\n    }\n    else {\n        // the actual longname is stored in `url` if there was a delimiter.\n        url = hasOwnProp.call(linkMap.longnameToUrl, longname) && linkMap.longnameToUrl[longname];\n    }\n\n    content = content || longname;\n    \n    if (!url) {\n        return content;\n    }\n    else {\n        if (monospace === undefined) {\n            // cleverLinks takes precedence. if cleverLinks is true\n            // we ignore monospaceLinks.\n            // If it's a symbol we use monospace font.\n            // Otherwise if cleverLinks is `false` we use monospaceLinks.\n            if (cleverLinks) {\n                monospace = !isURL;\n            } else {\n                monospace = monospaceLinks;\n            }\n        }\n        if (monospace) {\n            content = '<code>' + content + '</code>';\n        }\n        return '<a href=\"'+url+'\">'+content+'</a>';\n    }\n}\n\nvar tutorialToUrl = exports.tutorialToUrl = function(tutorial) {\n    var node = tutorials.getByName(tutorial);\n    // no such tutorial\n    if (!node) {\n        require('jsdoc/util/error').handle( new Error('No such tutorial: '+tutorial) );\n        return;\n    }\n\n    var url;\n    // define the URL if necessary\n    if (!hasOwnProp.call(tutorialLinkMap.nameToUrl, node.name)) {\n        url = 'tutorial-' + getUniqueFilename(node.name);\n        tutorialLinkMap.nameToUrl[node.name] = url;\n        tutorialLinkMap.urlToName[url] = node.name;\n    }\n\n    return tutorialLinkMap.nameToUrl[node.name];\n};\n\n/**\n * Retrieve a link to a tutorial, or the name of the tutorial if the tutorial is missing. If the\n * `missingOpts` parameter is supplied, the names of missing tutorials will be prefixed by the\n * specified text and wrapped in the specified HTML tag and CSS class.\n * @param {string} tutorial The name of the tutorial.\n * @param {string} content The link text to use.\n * @param {object} [missingOpts] Options for displaying the name of a missing tutorial.\n * @param {string} missingOpts.classname The CSS class to wrap around the tutorial name.\n * @param {string} missingOpts.prefix The prefix to add to the tutorial name.\n * @param {string} missingOpts.tag The tag to wrap around the tutorial name.\n * @return {string} An HTML link to the tutorial, or the name of the tutorial with the specified\n * options.\n */\nvar toTutorial = exports.toTutorial = function(tutorial, content, missingOpts) {\n    if (!tutorial) {\n        require('jsdoc/util/error').handle( new Error('Missing required parameter: tutorial') );\n        return;\n    }\n\n    var node = tutorials.getByName(tutorial);\n    // no such tutorial\n    if (!node) {\n        missingOpts = missingOpts || {};\n        var tag = missingOpts.tag;\n        var classname = missingOpts.classname;\n        \n        var link = tutorial;\n        if (missingOpts.prefix) {\n            link = missingOpts.prefix + link;\n        }\n        if (tag) {\n            link = '<' + tag + (classname ? (' class=\"' + classname + '\">') : '>') + link;\n            link += '</' + tag + '>';\n        }\n        return link;\n    }\n\n    content = content || node.title;\n\n    return '<a href=\"' + tutorialToUrl(tutorial) + '\">' + content + '</a>';\n};\n\n/** Find symbol {@link ...} and {@tutorial ...} strings in text and turn into html links */\nexports.resolveLinks = function(str) {\n    str = str.replace(/(?:\\[(.+?)\\])?\\{@link(plain|code)? +(.+?)\\}/gi,\n        function(match, content, monospace, longname) {\n            if (monospace === 'plain') {\n                monospace = false;\n            } else if (monospace === 'code') {\n                monospace = true;\n            } else {\n                monospace = undefined;\n            }\n            return toLink(longname, content, monospace);\n        }\n    );\n\n    str = str.replace(/(?:\\[(.+?)\\])?\\{@tutorial +(.+?)\\}/gi,\n        function(match, content, tutorial) {\n            return toTutorial(tutorial, content);\n        }\n    );\n\n    return str;\n};\n\n/** Convert tag text like \"Jane Doe <jdoe@example.org>\" into a mailto link */\nexports.resolveAuthorLinks = function(str) {\n    var author;\n    var matches = str.match(/^\\s?([\\s\\S]+)\\b\\s+<(\\S+@\\S+)>\\s?$/);\n    if (matches && matches.length === 3) {\n        author = '<a href=\"mailto:' + matches[2] + '\">' + htmlsafe(matches[1]) + '</a>';\n    }\n    else {\n        author = htmlsafe(str);\n    }\n\n    return author;\n};\n\n/**\n * Get a longname's filename if one has been registered; otherwise, generate a unique filename, then\n * register the filename.\n * @private\n */\nfunction getFilename(longname) {\n    var url;\n\n    if ( longnameToUrl[longname] && hasOwnProp.call(longnameToUrl, longname) ) {\n        url = longnameToUrl[longname];\n    } else {\n        url = getUniqueFilename(longname);\n        registerLink(longname, url);\n    }\n\n    return url;\n}\n\n/** Turn a doclet into a URL. */\nexports.createLink = function(doclet) {\n    var url = '';\n    var longname;\n    var filename;\n    \n    if (containers.indexOf(doclet.kind) < 0) {\n        longname = doclet.longname;\n        filename = getFilename(doclet.memberof || exports.globalName);\n        \n        url = filename + '#' + getNamespace(doclet.kind) + doclet.name;\n    }\n    else {\n        longname = doclet.longname;\n        url = getFilename(longname);\n    }\n    \n    return url;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":17823}]],"length":17823}
