{"ts":1363976917604,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @module jsdoc/tag/type\n * \n * @author Michael Mathews <micmath@gmail.com>\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n\n/** @private */\nfunction getTagInfo(tagValue, canHaveName, canHaveType) {\n    var extractInlineTag = require('jsdoc/tag/inline').extractInlineTag;\n\n    var name = '';\n    var typeExpression = '';\n    var text = tagValue;\n    var typeAndText;\n    var typeOverride;\n\n    if (canHaveType) {\n        typeAndText = extractInlineTag(text);\n        typeExpression = typeAndText.text || typeExpression;\n        text = typeAndText.newString;\n    }\n    \n    if (canHaveName) {\n        // like: name, [name], name text, [name] text, name - text, or [name] - text\n        text.match(/^(\\[[^\\]]+\\]|\\S+)((?:\\s*\\-\\s*|\\s+)(\\S[\\s\\S]*))?$/);\n        name = RegExp.$1;\n        text = RegExp.$3;\n    }\n\n    // an inline @type tag, like {@type Foo}, overrides the type expression\n    if (canHaveType) {\n        typeOverride = extractInlineTag(text, '@type');\n        typeExpression = typeOverride.text || typeExpression;\n        text = typeOverride.newString;\n    }\n    \n    return {\n        name: name,\n        typeExpression: typeExpression,\n        text: text\n    };\n}\n\n/**\n * Information provided in a JSDoc tag.\n *\n * @typedef {Object} TagInfo\n * @memberof module:jsdoc/tag/type\n * @property {string} TagInfo.defaultvalue - The default value of the member.\n * @property {string} TagInfo.name - The name of the member (for example, `myParamName`).\n * @property {boolean} TagInfo.nullable - Indicates whether the member can be set to `null` or\n * `undefined`.\n * @property {boolean} TagInfo.optional - Indicates whether the member is optional.\n * @property {string} TagInfo.text - Descriptive text for the member (for example, `The user's email\n * address.`).\n * @property {Array.<string>} TagInfo.type - The type or types that the member can contain (for\n * example, `string` or `MyNamespace.MyClass`).\n * @property {string} TagInfo.typeExpression - The type expression that was parsed to identify the\n * types.\n * @property {boolean} TagInfo.variable - Indicates whether the number of members that are provided\n * can vary (for example, in a function that accepts any number of parameters).\n */\n\n/**\n * Extract JSDoc-style type information from the name specified in the tag info, including the\n * member name; whether the member is optional; and the default value of the member.\n * \n * @private\n * @param {module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.\n * @return {module:jsdoc/tag/type.TagInfo} Updated information from the tag.\n */\nfunction parseName(tagInfo) {\n    // like '[foo]' or '[ foo ]' or '[foo=bar]' or '[ foo=bar ]' or '[ foo = bar ]'\n    if ( /^\\[\\s*(.+?)\\s*\\]$/.test(tagInfo.name) ) {\n        tagInfo.name = RegExp.$1;\n        tagInfo.optional = true;\n        \n        // like 'foo=bar' or 'foo = bar'\n        if ( /^(.+?)\\s*=\\s*(.+)$/.test(tagInfo.name) ) {\n            tagInfo.name = RegExp.$1;\n            tagInfo.defaultvalue = RegExp.$2;\n        }\n    }\n    \n    return tagInfo;\n}\n\n/** @private */\nfunction getTypeStrings(parsedType) {\n    var types = [];\n\n    var catharsis = require('catharsis');\n    var TYPES = catharsis.Types;\n    var util = require('util');\n\n    switch(parsedType.type) {\n        case TYPES.AllLiteral:\n            types.push('*');\n            break;\n        case TYPES.FunctionType:\n            types.push('function');\n            break;\n        case TYPES.NameExpression:\n            types.push(parsedType.name);\n            break;\n        case TYPES.NullLiteral:\n            types.push('null');\n            break;\n        case TYPES.RecordType:\n            types.push('Object');\n            break;\n        case TYPES.TypeApplication:\n            types.push( catharsis.stringify(parsedType) );\n            break;\n        case TYPES.TypeUnion:\n            parsedType.elements.forEach(function(element) {\n                types = types.concat( getTypeStrings(element) );\n            });\n            break;\n        case TYPES.UndefinedLiteral:\n            types.push('undefined');\n            break;\n        case TYPES.UnknownLiteral:\n            types.push('?');\n            break;\n        default:\n            // this shouldn't happen\n            throw new Error( util.format('unrecognized type %s in parsed type: %j', parsedType.type,\n                parsedType) );\n    }\n\n    return types;\n}\n\n/**\n * Extract JSDoc-style and Closure Compiler-style type information from the type expression\n * specified in the tag info.\n *\n * @private\n * @param {module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.\n * @return {module:jsdoc/tag/type.TagInfo} Updated information from the tag.\n */\nfunction parseTypeExpression(tagInfo) {\n    var catharsis = require('catharsis');\n    var util = require('util');\n\n    var errorMessage;\n    var parsedType;\n\n    // don't try to parse empty type expressions\n    if (!tagInfo.typeExpression) {\n        return tagInfo;\n    }\n    \n    try {\n        parsedType = catharsis.parse(tagInfo.typeExpression, {jsdoc: true});\n    }\n    catch (e) {\n        // always re-throw so the caller has a chance to report which file was bad\n        throw new Error( util.format('unable to parse the type expression \"%s\": %s',\n            tagInfo.typeExpression, e.message) );\n    }\n\n    if (parsedType) {\n        tagInfo.type = tagInfo.type.concat( getTypeStrings(parsedType) );\n\n        ['optional', 'nullable', 'variable'].forEach(function(key) {\n            if (parsedType[key] !== null && parsedType[key] !== undefined) {\n                tagInfo[key] = parsedType[key];\n            }\n        });\n    }\n\n    return tagInfo;\n}\n\n// TODO: allow users to add/remove type parsers (perhaps via plugins)\nvar typeParsers = [parseName, parseTypeExpression];\n\n/**\n * Parse the value of a JSDoc tag.\n *\n * @param {string} tagValue - The value of the tag. For example, the tag `@param {string} name` has\n * a value of `{string} name`.\n * @param {boolean} canHaveName - Indicates whether the value can include a member name.\n * @param {boolean} canHaveType - Indicates whether the value can include a type expression that\n * describes the member.\n * @return {module:jsdoc/tag/type.TagInfo} Information obtained from the tag.\n * @throws {Error} Thrown if a type expression cannot be parsed.\n */\nexports.parse = function(tagValue, canHaveName, canHaveType) {\n    if (typeof tagValue !== 'string') { tagValue = ''; }\n    \n    var tagInfo = getTagInfo(tagValue, canHaveName, canHaveType);\n    tagInfo.type = tagInfo.type || [];\n    \n    typeParsers.forEach(function(parser) {\n        tagInfo = parser.call(this, tagInfo);\n    });\n\n    // if we wanted a type, but the parsers didn't add any type names, use the type expression\n    if (canHaveType && !tagInfo.type.length && tagInfo.typeExpression) {\n        tagInfo.type = [tagInfo.typeExpression];\n    }\n\n    return tagInfo;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":6966}]],"length":6966}
